/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Wapikit
 * The Cloud Edition API collection for WapiKit
 * OpenAPI spec version: 0.0.1
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";
import { customInstance } from "~/api-client";
export type CountryEnum = (typeof CountryEnum)[keyof typeof CountryEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CountryEnum = {
  United_States: "United States",
  European_Union: "European Union",
  Japan: "Japan",
  United_Kingdom: "United Kingdom",
  Australia: "Australia",
  Canada: "Canada",
  Switzerland: "Switzerland",
  China: "China",
  Sweden: "Sweden",
  New_Zealand: "New Zealand",
  India: "India",
  Russia: "Russia",
  Brazil: "Brazil",
  South_Africa: "South Africa",
  Mexico: "Mexico",
  Singapore: "Singapore",
  Hong_Kong: "Hong Kong",
  Norway: "Norway",
  South_Korea: "South Korea",
  Turkey: "Turkey",
  Indonesia: "Indonesia",
  Thailand: "Thailand",
  Malaysia: "Malaysia",
  Philippines: "Philippines",
  Poland: "Poland",
  Denmark: "Denmark",
  Hungary: "Hungary",
  Czech_Republic: "Czech Republic",
  Israel: "Israel",
  Chile: "Chile",
  Pakistan: "Pakistan",
  United_Arab_Emirates: "United Arab Emirates",
  Colombia: "Colombia",
  Saudi_Arabia: "Saudi Arabia",
  Taiwan: "Taiwan",
  Vietnam: "Vietnam",
  Nigeria: "Nigeria",
  Bangladesh: "Bangladesh",
  Egypt: "Egypt",
  Kazakhstan: "Kazakhstan",
  Qatar: "Qatar",
  Kenya: "Kenya",
  Sri_Lanka: "Sri Lanka",
  Peru: "Peru",
  Ukraine: "Ukraine",
  Romania: "Romania",
  Zambia: "Zambia",
  Oman: "Oman",
} as const;

export type CurrencyEnum = (typeof CurrencyEnum)[keyof typeof CurrencyEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CurrencyEnum = {
  USD: "USD",
  EUR: "EUR",
  JPY: "JPY",
  GBP: "GBP",
  AUD: "AUD",
  CAD: "CAD",
  CHF: "CHF",
  CNY: "CNY",
  SEK: "SEK",
  NZD: "NZD",
  INR: "INR",
  RUB: "RUB",
  BRL: "BRL",
  ZAR: "ZAR",
  MXN: "MXN",
  SGD: "SGD",
  HKD: "HKD",
  NOK: "NOK",
  KRW: "KRW",
  TRY: "TRY",
  IDR: "IDR",
  THB: "THB",
  MYR: "MYR",
  PHP: "PHP",
  PLN: "PLN",
  DKK: "DKK",
  HUF: "HUF",
  CZK: "CZK",
  ILS: "ILS",
  CLP: "CLP",
  PKR: "PKR",
  AED: "AED",
  COP: "COP",
  SAR: "SAR",
  TWD: "TWD",
  VND: "VND",
  NGN: "NGN",
  BDT: "BDT",
  EGP: "EGP",
  KZT: "KZT",
  QAR: "QAR",
  KES: "KES",
  LKR: "LKR",
  PEN: "PEN",
  UAH: "UAH",
  RON: "RON",
  ZMW: "ZMW",
  OMR: "OMR",
} as const;

export type PlanValidityEnum =
  (typeof PlanValidityEnum)[keyof typeof PlanValidityEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PlanValidityEnum = {
  Monthly: "Monthly",
  Yearly: "Yearly",
} as const;

export type PlanTypeEnum = (typeof PlanTypeEnum)[keyof typeof PlanTypeEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PlanTypeEnum = {
  Subscription: "Subscription",
  OneTime: "OneTime",
} as const;

export type SubscriptionStatusEnum =
  (typeof SubscriptionStatusEnum)[keyof typeof SubscriptionStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SubscriptionStatusEnum = {
  Active: "Active",
  Cancelled: "Cancelled",
  Upgraded: "Upgraded",
} as const;

export type PurchaseGatewayEnum =
  (typeof PurchaseGatewayEnum)[keyof typeof PurchaseGatewayEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PurchaseGatewayEnum = {
  Stripe: "Stripe",
  Razorpay: "Razorpay",
  Paypal: "Paypal",
} as const;

export type PurchaseStatusEnum =
  (typeof PurchaseStatusEnum)[keyof typeof PurchaseStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PurchaseStatusEnum = {
  Paid: "Paid",
  Refunded: "Refunded",
} as const;

export type PricingPlanTierEnum =
  (typeof PricingPlanTierEnum)[keyof typeof PricingPlanTierEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PricingPlanTierEnum = {
  Pro: "Pro",
  Scale: "Scale",
  ScalePlus: "ScalePlus",
  ScaleMax: "ScaleMax",
  Free: "Free",
  Enterprise: "Enterprise",
} as const;

export interface PricingPlan {
  uniqueId: string;
  title: string;
  description: string;
  validity: PlanValidityEnum;
  priceString: string;
  ctaText: string;
  shouldCtaBeDisabled: boolean;
  actualPriceInLowestCurrencyUnits: number;
  finalPriceInLowestCurrencyUnits: number;
  discountCouponApplied?: DiscountCoupon;
  currency: CurrencyEnum;
  currencySymbol: string;
  isPopular: boolean;
  tier: PricingPlanTierEnum;
}

export interface DiscountCoupon {
  uniqueId: string;
  title: string;
  code: string;
  percentageDiscount: number;
}

export interface CheckoutResponseSchema {
  razorpaySessionId: string;
  verificationToken: string;
}

export interface GetPricingPlansResponseSchema {
  plans: PricingPlan[];
}

export interface VerifyPaymentResponseSchema {
  isVerified: boolean;
}

export interface CancelSubscriptionResponseSchema {
  isCancelled: boolean;
}

export interface RefundPaymentResponseSchema {
  isRefundedInitiated?: boolean;
}

export interface SubscriptionDetails {
  uniqueId: string;
  tier: PricingPlanTierEnum;
  status: SubscriptionStatusEnum;
  gateway: PurchaseGatewayEnum;
  willBeCancelledAtEndOfPeriod: boolean;
  validTill: string;
  validityDuration: PlanValidityEnum;
  isRefundAllowed: boolean;
}

export interface GetSubscriptionDetailsResponseSchema {
  subscriptionDetails: SubscriptionDetails;
}

export interface NotFoundErrorResponseSchema {
  message: string;
}

export interface InternalServerErrorResponseSchema {
  message: string;
}

export interface RateLimitErrorResponseSchema {
  message: string;
  remaining: number;
  reset: number;
}

export interface BadRequestErrorResponseSchema {
  message: string;
}

export interface UnauthorizedErrorResponseSchema {
  message: string;
}

export type CheckoutPaymentParams = {
  /**
   * The discount coupon to apply
   */
  discountCode?: string;
  /**
   * The plan uniqueId to checkout for
   */
  planId: string;
  /**
 * The currency to fetch plans in
 */
  currency: CurrencyEnum;
};

export type GetPaymentPlansParams = {
  /**
   * The discount coupon to apply
   */
  discountCode?: string;
  /**
   * The currency to fetch plans in
   */
  currency?: CurrencyEnum;
};

export type VerifyPaymentParams = {
  /**
   * The verification token
   */
  verificationToken: string;
};

export type CancelSubscriptionParams = {
  /**
   * The subscription id to cancel
   */
  subscriptionId: string;
};

export type RefundPaymentParams = {
  /**
   * The payment id to refund
   */
  paymentId: string;
};

/**
 * Checkout Payment
 * @summary Checkout payment
 */
export const checkoutPayment = (
  params: CheckoutPaymentParams,
  signal?: AbortSignal,
) => {
  return customInstance<CheckoutResponseSchema>({
    url: `/payment/checkout`,
    method: "POST",
    params,
    signal,
  });
};

export const getCheckoutPaymentMutationOptions = <
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkoutPayment>>,
    TError,
    { params: CheckoutPaymentParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof checkoutPayment>>,
  TError,
  { params: CheckoutPaymentParams },
  TContext
> => {
  const mutationKey = ["checkoutPayment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof checkoutPayment>>,
    { params: CheckoutPaymentParams }
  > = (props) => {
    const { params } = props ?? {};

    return checkoutPayment(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CheckoutPaymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof checkoutPayment>>
>;

export type CheckoutPaymentMutationError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema;

/**
 * @summary Checkout payment
 */
export const useCheckoutPayment = <
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkoutPayment>>,
    TError,
    { params: CheckoutPaymentParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof checkoutPayment>>,
  TError,
  { params: CheckoutPaymentParams },
  TContext
> => {
  const mutationOptions = getCheckoutPaymentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * Get all payment plans
 * @summary Get all payment plans
 */
export const getPaymentPlans = (
  params?: GetPaymentPlansParams,
  signal?: AbortSignal,
) => {
  return customInstance<GetPricingPlansResponseSchema>({
    url: `/payment/plans`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPaymentPlansQueryKey = (params?: GetPaymentPlansParams) => {
  return [`/payment/plans`, ...(params ? [params] : [])] as const;
};

export const getGetPaymentPlansQueryOptions = <
  TData = Awaited<ReturnType<typeof getPaymentPlans>>,
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
>(
  params?: GetPaymentPlansParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getPaymentPlans>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPaymentPlansQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPaymentPlans>>> = ({
    signal,
  }) => getPaymentPlans(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPaymentPlans>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPaymentPlansQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPaymentPlans>>
>;
export type GetPaymentPlansQueryError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema;

/**
 * @summary Get all payment plans
 */

export function useGetPaymentPlans<
  TData = Awaited<ReturnType<typeof getPaymentPlans>>,
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
>(
  params?: GetPaymentPlansParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getPaymentPlans>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPaymentPlansQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * verify payment
 * @summary Verify payment
 */
export const verifyPayment = (
  params: VerifyPaymentParams,
  signal?: AbortSignal,
) => {
  return customInstance<VerifyPaymentResponseSchema>({
    url: `/payment/verify`,
    method: "GET",
    params,
    signal,
  });
};

export const getVerifyPaymentQueryKey = (params: VerifyPaymentParams) => {
  return [`/payment/verify`, ...(params ? [params] : [])] as const;
};

export const getVerifyPaymentQueryOptions = <
  TData = Awaited<ReturnType<typeof verifyPayment>>,
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
>(
  params: VerifyPaymentParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof verifyPayment>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVerifyPaymentQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyPayment>>> = ({
    signal,
  }) => verifyPayment(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof verifyPayment>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type VerifyPaymentQueryResult = NonNullable<
  Awaited<ReturnType<typeof verifyPayment>>
>;
export type VerifyPaymentQueryError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema;

/**
 * @summary Verify payment
 */

export function useVerifyPayment<
  TData = Awaited<ReturnType<typeof verifyPayment>>,
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
>(
  params: VerifyPaymentParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof verifyPayment>>,
      TError,
      TData
    >;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getVerifyPaymentQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * cancel subscription
 * @summary Cancel subscription
 */
export const cancelSubscription = (
  params: CancelSubscriptionParams,
  signal?: AbortSignal,
) => {
  return customInstance<CancelSubscriptionResponseSchema>({
    url: `/subscription/cancel`,
    method: "POST",
    params,
    signal,
  });
};

export const getCancelSubscriptionMutationOptions = <
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelSubscription>>,
    TError,
    { params: CancelSubscriptionParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelSubscription>>,
  TError,
  { params: CancelSubscriptionParams },
  TContext
> => {
  const mutationKey = ["cancelSubscription"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelSubscription>>,
    { params: CancelSubscriptionParams }
  > = (props) => {
    const { params } = props ?? {};

    return cancelSubscription(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelSubscriptionMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelSubscription>>
>;

export type CancelSubscriptionMutationError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema;

/**
 * @summary Cancel subscription
 */
export const useCancelSubscription = <
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelSubscription>>,
    TError,
    { params: CancelSubscriptionParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof cancelSubscription>>,
  TError,
  { params: CancelSubscriptionParams },
  TContext
> => {
  const mutationOptions = getCancelSubscriptionMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * refund payment
 * @summary Refund payment
 */
export const refundPayment = (
  params: RefundPaymentParams,
  signal?: AbortSignal,
) => {
  return customInstance<RefundPaymentResponseSchema>({
    url: `/subscription/refund`,
    method: "POST",
    params,
    signal,
  });
};

export const getRefundPaymentMutationOptions = <
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refundPayment>>,
    TError,
    { params: RefundPaymentParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refundPayment>>,
  TError,
  { params: RefundPaymentParams },
  TContext
> => {
  const mutationKey = ["refundPayment"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refundPayment>>,
    { params: RefundPaymentParams }
  > = (props) => {
    const { params } = props ?? {};

    return refundPayment(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefundPaymentMutationResult = NonNullable<
  Awaited<ReturnType<typeof refundPayment>>
>;

export type RefundPaymentMutationError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema;

/**
 * @summary Refund payment
 */
export const useRefundPayment = <
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema
  | InternalServerErrorResponseSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refundPayment>>,
    TError,
    { params: RefundPaymentParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof refundPayment>>,
  TError,
  { params: RefundPaymentParams },
  TContext
> => {
  const mutationOptions = getRefundPaymentMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 * get subscription details
 * @summary Get subscription details
 */
export const getSubscriptionDetails = (signal?: AbortSignal) => {
  return customInstance<GetSubscriptionDetailsResponseSchema>({
    url: `/subscription`,
    method: "GET",
    signal,
  });
};

export const getGetSubscriptionDetailsQueryKey = () => {
  return [`/subscription`] as const;
};

export const getGetSubscriptionDetailsQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubscriptionDetails>>,
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema,
>(options?: {
  query?: Partial<UseQueryOptions<
    Awaited<ReturnType<typeof getSubscriptionDetails>>,
    TError,
    TData
  >>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSubscriptionDetailsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSubscriptionDetails>>
  > = ({ signal }) => getSubscriptionDetails(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSubscriptionDetails>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetSubscriptionDetailsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubscriptionDetails>>
>;
export type GetSubscriptionDetailsQueryError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema;

/**
 * @summary Get subscription details
 */

export function useGetSubscriptionDetails<
  TData = Awaited<ReturnType<typeof getSubscriptionDetails>>,
  TError =
  | BadRequestErrorResponseSchema
  | UnauthorizedErrorResponseSchema
  | NotFoundErrorResponseSchema
  | RateLimitErrorResponseSchema,
>(options?: {
  query?: Partial<UseQueryOptions<
    Awaited<ReturnType<typeof getSubscriptionDetails>>,
    TError,
    TData
  >>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetSubscriptionDetailsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
