/**
 * Generated by orval v7.5.0 ðŸº
 * Do not edit manually.
 * Wapikit
 * The API collection for WapiKit
 * OpenAPI spec version: 0.0.1
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult
} from '@tanstack/react-query'
import { customInstance } from './src/utils/api-client'
export type OrderEnum = (typeof OrderEnum)[keyof typeof OrderEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderEnum = {
	asc: 'asc',
	desc: 'desc'
} as const

export type ConversationStatusEnum =
	(typeof ConversationStatusEnum)[keyof typeof ConversationStatusEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConversationStatusEnum = {
	Active: 'Active',
	Closed: 'Closed',
	Deleted: 'Deleted'
} as const

export type UserPermissionLevelEnum =
	(typeof UserPermissionLevelEnum)[keyof typeof UserPermissionLevelEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserPermissionLevelEnum = {
	Owner: 'Owner',
	Member: 'Member'
} as const

export type InviteStatusEnum = (typeof InviteStatusEnum)[keyof typeof InviteStatusEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const InviteStatusEnum = {
	Pending: 'Pending',
	Redeemed: 'Redeemed'
} as const

export type CampaignStatusEnum = (typeof CampaignStatusEnum)[keyof typeof CampaignStatusEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CampaignStatusEnum = {
	Draft: 'Draft',
	Scheduled: 'Scheduled',
	Running: 'Running',
	Paused: 'Paused',
	Cancelled: 'Cancelled',
	Finished: 'Finished'
} as const

export type UserAccountStatusEnum =
	(typeof UserAccountStatusEnum)[keyof typeof UserAccountStatusEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserAccountStatusEnum = {
	Active: 'Active',
	Deleted: 'Deleted',
	Suspended: 'Suspended'
} as const

export type MessageStatusEnum = (typeof MessageStatusEnum)[keyof typeof MessageStatusEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageStatusEnum = {
	Read: 'Read',
	Unread: 'Unread',
	Sent: 'Sent',
	Delivered: 'Delivered',
	UnDelivered: 'UnDelivered',
	Failed: 'Failed'
} as const

export type MessageDirectionEnum = (typeof MessageDirectionEnum)[keyof typeof MessageDirectionEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageDirectionEnum = {
	InBound: 'InBound',
	OutBound: 'OutBound'
} as const

export type MessageTypeEnum = (typeof MessageTypeEnum)[keyof typeof MessageTypeEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageTypeEnum = {
	Text: 'Text',
	Image: 'Image',
	Video: 'Video',
	Audio: 'Audio',
	Document: 'Document',
	Sticker: 'Sticker',
	Location: 'Location',
	Contacts: 'Contacts',
	Reaction: 'Reaction',
	Address: 'Address'
} as const

export type ContactStatusEnum = (typeof ContactStatusEnum)[keyof typeof ContactStatusEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ContactStatusEnum = {
	Active: 'Active',
	Inactive: 'Inactive',
	Blocked: 'Blocked'
} as const

export type RolePermissionEnum = (typeof RolePermissionEnum)[keyof typeof RolePermissionEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RolePermissionEnum = {
	'Get:OrganizationMember': 'Get:OrganizationMember',
	'Create:OrganizationMember': 'Create:OrganizationMember',
	'Update:OrganizationMember': 'Update:OrganizationMember',
	'Delete:OrganizationMember': 'Delete:OrganizationMember',
	'Get:Campaign': 'Get:Campaign',
	'Create:Campaign': 'Create:Campaign',
	'Update:Campaign': 'Update:Campaign',
	'Delete:Campaign': 'Delete:Campaign',
	'Get:Conversation': 'Get:Conversation',
	'Update:Conversation': 'Update:Conversation',
	'Delete:Conversation': 'Delete:Conversation',
	'Assign:Conversation': 'Assign:Conversation',
	'Unassign:Conversation': 'Unassign:Conversation',
	'Get:List': 'Get:List',
	'Create:List': 'Create:List',
	'Update:List': 'Update:List',
	'Delete:List': 'Delete:List',
	'Get:Tag': 'Get:Tag',
	'Create:Tag': 'Create:Tag',
	'Update:Tag': 'Update:Tag',
	'Delete:Tag': 'Delete:Tag',
	'Get:ApiKey': 'Get:ApiKey',
	'Regenerate:ApiKey': 'Regenerate:ApiKey',
	'Get:AppSettings': 'Get:AppSettings',
	'Update:AppSettings': 'Update:AppSettings',
	'Get:Contact': 'Get:Contact',
	'Create:Contact': 'Create:Contact',
	'Update:Contact': 'Update:Contact',
	'Delete:Contact': 'Delete:Contact',
	'BulkImport:Contacts': 'BulkImport:Contacts',
	'Get:PrimaryAnalytics': 'Get:PrimaryAnalytics',
	'Get:SecondaryAnalytics': 'Get:SecondaryAnalytics',
	'Get:CampaignAnalytics': 'Get:CampaignAnalytics',
	'Update:Organization': 'Update:Organization',
	'Get:OrganizationRole': 'Get:OrganizationRole',
	'Create:OrganizationRole': 'Create:OrganizationRole',
	'Update:OrganizationRole': 'Update:OrganizationRole',
	'Delete:OrganizationRole': 'Delete:OrganizationRole',
	'Update:IntegrationSettings': 'Update:IntegrationSettings',
	'Get:MessageTemplates': 'Get:MessageTemplates',
	'Get:PhoneNumbers': 'Get:PhoneNumbers'
} as const

export type IntegrationStatusEnum =
	(typeof IntegrationStatusEnum)[keyof typeof IntegrationStatusEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const IntegrationStatusEnum = {
	Active: 'Active',
	Inactive: 'Inactive'
} as const

export type ConversationInitiatedByEnum =
	(typeof ConversationInitiatedByEnum)[keyof typeof ConversationInitiatedByEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConversationInitiatedByEnum = {
	Contact: 'Contact',
	Campaign: 'Campaign'
} as const

export type AiChatStatusEnum = (typeof AiChatStatusEnum)[keyof typeof AiChatStatusEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AiChatStatusEnum = {
	Active: 'Active',
	Inactive: 'Inactive'
} as const

export type AiChatVisibilityEnum = (typeof AiChatVisibilityEnum)[keyof typeof AiChatVisibilityEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AiChatVisibilityEnum = {
	Public: 'Public',
	Private: 'Private'
} as const

export type AiChatMessageVoteEnum =
	(typeof AiChatMessageVoteEnum)[keyof typeof AiChatMessageVoteEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AiChatMessageVoteEnum = {
	Upvote: 'Upvote',
	Downvote: 'Downvote'
} as const

export type AiModelEnum = (typeof AiModelEnum)[keyof typeof AiModelEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AiModelEnum = {
	Gpt4: 'Gpt4',
	GptO1: 'GptO1',
	GptO3Mini: 'GptO3Mini',
	Gpt4oMini: 'Gpt4oMini',
	Mistral: 'Mistral',
	Gpt4o: 'Gpt4o',
	Gemini15Pro: 'Gemini1.5Pro',
	Claude35: 'Claude3.5'
} as const

export interface IntegrationSchema {
	uniqueId: string
	name: string
	type: string
	slug: string
	icon: string
	description: string
	isPremium: boolean
	createdAt: string
	status: IntegrationStatusEnum
}

export interface IntegrationFeatureFlags {
	isSlackIntegrationEnabled: boolean
	isCustomChatBoxIntegrationEnabled: boolean
	isOpenAiIntegrationEnabled: boolean
}

export interface SystemFeatureFlags {
	isCloudEdition: boolean
	isEnterpriseEdition: boolean
	isRoleBasedAccessControlEnabled: boolean
	isMultiOrganizationEnabled: boolean
	isApiAccessEnabled: boolean
	isAiIntegrationEnabled: boolean
	isPluginIntegrationMarketplaceEnabled: boolean
}

export interface FeatureFlags {
	SystemFeatureFlags: SystemFeatureFlags
}

export interface UserSchema {
	uniqueId: string
	username: string
	email: string
	name: string
	createdAt: string
	profilePicture?: string
	currentOrganizationAccessLevel?: UserPermissionLevelEnum
	organization?: OrganizationSchema
	featureFlags?: FeatureFlags
	isOwner: boolean
}

export interface GetUserResponseSchema {
	user: UserSchema
}

export interface OrganizationSchema {
	uniqueId: string
	name: string
	description?: string
	createdAt: string
	websiteUrl?: string
	logoUrl?: string
	faviconUrl?: string
	businessAccountId?: string
	whatsappBusinessAccountDetails?: WhatsAppBusinessAccountDetailsSchema
	slackNotificationConfiguration?: SlackNotificationConfigurationSchema
	emailNotificationConfiguration?: EmailNotificationConfigurationSchema
	aiConfiguration?: AiConfigurationDetailsSchema
}

export interface SlackNotificationConfigurationSchema {
	slackChannel: string
	slackWebhookUrl: string
}

export interface EmailNotificationConfigurationSchema {
	smtpHost: string
	smtpPort: string
	smtpUsername: string
	smtpPassword: string
}

export interface OrganizationMemberSchema {
	uniqueId: string
	createdAt: string
	accessLevel: UserPermissionLevelEnum
	name: string
	email: string
	roles: OrganizationRoleSchema[]
}

export interface LoginRequestBodySchema {
	username: string
	password: string
}

export interface LoginResponseBodySchema {
	token: string
	isOnboardingCompleted: boolean
}

export interface RegisterRequestBodySchema {
	username: string
	email: string
	password: string
	name: string
	organizationInviteSlug?: string
}

export interface RegisterRequestResponseBodySchema {
	isOtpSent: boolean
}

export interface VerifyOtpRequestBodySchema {
	username: string
	email: string
	password: string
	name: string
	organizationInviteSlug?: string
	otp: string
}

export interface VerifyOtpResponseBodySchema {
	token: string
}

export interface GetFeatureFlagsResponseSchema {
	featureFlags: FeatureFlags
}

export interface GetMetaDataResponseSchema {
	metaTitle?: string
	metaDescription?: string
	faviconUrl?: string
}

export interface OrganizationMemberInviteSchema {
	uniqueId: string
	email: string
	accessLevel: UserPermissionLevelEnum
	createdAt: string
	status: InviteStatusEnum
	organizationName: string
}

export interface CreateNewOrganizationInviteSchema {
	email: string
	accessLevel: UserPermissionLevelEnum
}

export interface CreateInviteResponseSchema {
	invite: OrganizationMemberInviteSchema
}

export interface JoinOrganizationRequestBodySchema {
	inviteSlug?: string
}

export interface JoinOrganizationResponseBodySchema {
	token: string
}

export interface UnassignConversationResponseSchema {
	data: boolean
}

export interface UnassignConversationSchema {
	userId: string
}

export interface AssignConversationSchema {
	organizationMemberId: string
}

export interface AssignConversationResponseSchema {
	data: boolean
}

export interface RegenerateApiKeyResponseSchema {
	apiKey?: ApiKeySchema
}

export interface GetOrganizationMemberInvitesResponseSchema {
	invites: OrganizationMemberInviteSchema[]
	paginationMeta: PaginationMeta
}

export interface DeleteInviteResponseSchema {
	data: boolean
}

export interface ApiKeySchema {
	uniqueId: string
	key: string
	createdAt: string
}

export interface GetApiKeysResponseSchema {
	apiKey: ApiKeySchema
}

export interface SwitchOrganizationResponseSchema {
	token: string
}

export interface GetCampaignResponseSchema {
	campaigns: CampaignSchema[]
	paginationMeta: PaginationMeta
}

export interface CreateNewContactResponseSchema {
	message: string
}

export interface CreateNewCampaignResponseSchema {
	campaign: CampaignSchema
}

export interface UpdateCampaignByIdResponseSchema {
	isUpdated: boolean
}

export interface NewOrganizationTagSchema {
	label: string
}

export interface UpdateOrganizationMemberRoleSchema {
	updatedRoleIds: string[]
}

export interface GetOrganizationTagsResponseSchema {
	tags: TagSchema[]
	paginationMeta: PaginationMeta
}

export interface CreateNewOrganizationTagResponseSchema {
	tag: TagSchema
}

export interface GetContactListResponseSchema {
	lists: ContactListSchema[]
	paginationMeta: PaginationMeta
}

export interface GetTemplateByIdResponseSchema {
	template: TemplateSchema
}

export interface GetContactsResponseSchema {
	contacts: ContactSchema[]
	paginationMeta: PaginationMeta
}

export interface GetContactByIdResponseSchema {
	contact: ContactSchema
}

export interface GetContactListByIdSchema {
	list: ContactListSchema
}

export interface GetCampaignByIdResponseSchema {
	campaign: CampaignSchema
}

export interface NewOrganizationSchema {
	name: string
	description?: string
}

export interface UpdateOrganizationSchema {
	name: string
	description?: string
	slackNotificationConfiguration?: SlackNotificationConfigurationSchema
	emailNotificationConfiguration?: EmailNotificationConfigurationSchema
	aiConfiguration?: UpdateAIConfigurationDetailsSchema
}

export interface CreateNewOrganizationResponseSchema {
	organization: OrganizationSchema
}

export interface GetOrganizationsResponseSchema {
	organizations: OrganizationSchema[]
	paginationMeta: PaginationMeta
}

export interface GetOrganizationByIdResponseSchema {
	organization: OrganizationSchema
}

export interface UpdateOrganizationByIdResponseSchema {
	isUpdated: boolean
}

export interface DeleteOrganizationResponseSchema {
	data: boolean
}

export interface UpdateOrganizationResponseSchema {
	organization: OrganizationSchema
}

export interface GetOrganizationRolesResponseSchema {
	roles: OrganizationRoleSchema[]
	paginationMeta: PaginationMeta
}

export type UpdateOrganizationSettingsResponseSchemaSetting = {
	key?: string
	value?: string
}

export interface UpdateOrganizationSettingsResponseSchema {
	setting?: UpdateOrganizationSettingsResponseSchemaSetting
}

export interface GetOrganizationMembersResponseSchema {
	members: OrganizationMemberSchema[]
	paginationMeta: PaginationMeta
}

export interface GetOrganizationMemberRolesResponseSchema {
	roles: OrganizationRoleSchema[]
	paginationMeta: PaginationMeta
}

export interface GetOrganizationMemberByIdResponseSchema {
	member: OrganizationMemberSchema
}

export interface CreateOrganizationMemberResponseSchema {
	member: OrganizationMemberSchema
}

export interface UpdateOrganizationMemberByIdResponseSchema {
	member: OrganizationMemberSchema
}

export interface DeleteOrganizationMemberByIdResponseSchema {
	data: boolean
}

export interface GetRoleByIdResponseSchema {
	role: OrganizationRoleSchema
}

export interface CreateNewRoleResponseSchema {
	role: OrganizationRoleSchema
}

export interface RoleUpdateSchema {
	name: string
	description?: string
	permissions: RolePermissionEnum[]
}

export interface UpdateRoleByIdResponseSchema {
	role: OrganizationRoleSchema
}

export interface DeleteRoleByIdResponseSchema {
	data: boolean
}

export interface ConversationWithoutContactSchema {
	uniqueId: string
	contactId: string
	campaignId?: string
	organizationId: string
	initiatedBy: ConversationInitiatedByEnum
	messages: MessageSchema[]
	createdAt: string
	status: ConversationStatusEnum
}

export type ContactSchemaAttributes = { [key: string]: unknown }

export interface ContactSchema {
	uniqueId: string
	name: string
	phone: string
	attributes: ContactSchemaAttributes
	createdAt: string
	lists: ContactListSchema[]
	conversations?: ConversationWithoutContactSchema[]
	status: ContactStatusEnum
}

export type NewContactSchemaAttributes = { [key: string]: unknown }

export interface NewContactSchema {
	name: string
	phone: string
	status: ContactStatusEnum
	attributes: NewContactSchemaAttributes
	listsIds: string[]
}

export interface NewOrganizationRoleSchema {
	name: string
	description?: string
	permissions: RolePermissionEnum[]
}

export interface OrganizationRoleSchema {
	uniqueId: string
	name: string
	description?: string
	permissions: RolePermissionEnum[]
}

export type UpdateContactSchemaAttributes = { [key: string]: unknown }

export interface UpdateContactSchema {
	name: string
	status: ContactStatusEnum
	phone: string
	attributes: UpdateContactSchemaAttributes
	lists: string[]
}

export interface UpdateContactByIdResponseSchema {
	contact: ContactSchema
}

export interface TagSchema {
	label: string
	uniqueId: string
}

export interface ContactListSchema {
	name: string
	description: string
	numberOfContacts: number
	numberOfCampaignsSent: number
	tags: TagSchema[]
	uniqueId: string
	createdAt: string
}

export interface NewContactListSchema {
	name: string
	description?: string
	tags: TagSchema[]
	contactIds?: string[]
}

export interface CreateNewListResponseSchema {
	list: ContactListSchema
}

export interface UpdateContactListSchema {
	name: string
	description?: string
	tags: TagSchema[]
}

export interface UpdateListByIdResponseSchema {
	list: ContactListSchema
}

export interface PaginationMeta {
	page: number
	per_page: number
	total: number
}

export interface UpdateOrganizationMemberSchema {
	accessLevel?: UserPermissionLevelEnum
}

export type TemplateSchemaHeader = {
	headerType?: string
	content?: string
}

export type TemplateSchemaFooter = { [key: string]: unknown }

export interface TemplateSchema {
	templateId: string
	bodyText: string
	header: TemplateSchemaHeader
	footer?: TemplateSchemaFooter
	content: string
	createdAt: string
}

export type CampaignSchemaTemplateComponentParameters = { [key: string]: unknown }

export interface CampaignSchema {
	uniqueId: string
	name: string
	description?: string
	status: CampaignStatusEnum
	sentAt?: string
	createdAt: string
	scheduledAt?: string
	lists: ContactListSchema[]
	templateMessageId?: string
	isLinkTrackingEnabled: boolean
	phoneNumberInUse?: string
	tags: TagSchema[]
	templateComponentParameters?: CampaignSchemaTemplateComponentParameters
	stats?: CampaignAnalyticsResponseSchema
}

export interface NewCampaignSchema {
	name: string
	description?: string
	listIds: string[]
	templateMessageId: string
	phoneNumberToUse: string
	isLinkTrackingEnabled: boolean
	scheduledAt?: string
	tags: string[]
}

export type UpdateCampaignSchemaTemplateComponentParameters = { [key: string]: unknown }

export interface UpdateCampaignSchema {
	name: string
	description?: string
	listIds: string[]
	templateMessageId?: string
	enableLinkTracking: boolean
	tags: string[]
	status?: CampaignStatusEnum
	phoneNumber?: string
	templateComponentParameters?: UpdateCampaignSchemaTemplateComponentParameters
	scheduledAt?: string
}

export type ContactWithoutConversationSchemaAttributes = { [key: string]: unknown }

export interface ContactWithoutConversationSchema {
	uniqueId: string
	name: string
	phone: string
	attributes: ContactWithoutConversationSchemaAttributes
	createdAt: string
	status: ContactStatusEnum
}

export interface ConversationSchema {
	contact: ContactWithoutConversationSchema
	uniqueId: string
	contactId: string
	campaignId?: string
	organizationId: string
	initiatedBy: ConversationInitiatedByEnum
	messages: MessageSchema[]
	createdAt: string
	numberOfUnreadMessages: number
	status: ConversationStatusEnum
	assignedTo?: OrganizationMemberSchema
	tags: TagSchema[]
}

export interface GetConversationByIdResponseSchema {
	conversation: ConversationSchema
}

export interface GetConversationMessagesResponseSchema {
	messages: MessageSchema[]
	paginationMeta: PaginationMeta
}

export interface GetConversationsResponseSchema {
	conversations: ConversationSchema[]
	paginationMeta: PaginationMeta
}

export interface UpdateConversationSchema {
	status: ConversationStatusEnum
}

export interface UpdateConversationByIdResponseSchema {
	conversation: ConversationSchema
}

export interface DeleteConversationByIdResponseSchema {
	data: boolean
}

export interface DeleteContactByIdResponseSchema {
	data: boolean
}

export type MessageSchemaMessageData = { [key: string]: unknown }

export interface MessageSchema {
	uniqueId: string
	conversationId: string
	direction: MessageDirectionEnum
	status: MessageStatusEnum
	message_type: MessageTypeEnum
	createdAt: string
	messageData?: MessageSchemaMessageData
}

export type NewMessageSchemaMessageData = { [key: string]: unknown }

export interface NewMessageSchema {
	messageType?: MessageTypeEnum
	createdAt?: string
	messageData?: NewMessageSchemaMessageData
}

export interface SendMessageInConversationResponseSchema {
	message: MessageSchema
}

export interface ErrorSchema {
	message: string
}

export interface TransferOrganizationOwnershipSchema {
	newOwnerId: string
}

export interface TransferOrganizationOwnershipResponseSchema {
	isTransferred: boolean
}

export interface BulkImportSchema {
	listIds?: string[]
	delimiter?: string
}

export interface BulkImportResponseSchema {
	message: string
}

export interface AggregateMessageStatsDataPointsSchema {
	totalMessages: number
	messagesSent: number
	messagesFailed: number
	messagesDelivered: number
	messagesUndelivered: number
	messagesRead: number
	messagesUnread: number
}

export interface AggregateConversationStatsDataPointsSchema {
	totalConversations: number
	conversationsActive: number
	conversationsClosed: number
	conversationsPending: number
}

export interface AggregateCampaignStatsDataPointsSchema {
	totalCampaigns: number
	campaignsDraft: number
	campaignsScheduled: number
	campaignsRunning: number
	campaignsPaused: number
	campaignsCancelled: number
	campaignsFinished: number
}

export interface AggregateContactStatsDataPointsSchema {
	totalContacts: number
	contactsActive: number
	contactsBlocked: number
}

export interface AggregateAnalyticsSchema {
	messageStats: AggregateMessageStatsDataPointsSchema
	conversationStats: AggregateConversationStatsDataPointsSchema
	campaignStats: AggregateCampaignStatsDataPointsSchema
	contactStats: AggregateContactStatsDataPointsSchema
}

export interface MessageAnalyticGraphDataPointSchema {
	date: string
	label: string
	sent: number
	replied: number
	read: number
}

export interface MessageTypeDistributionGraphDataPointSchema {
	type: string
	sent: number
	received: number
}

export interface LinkClicksGraphDataPointSchema {
	date: string
	label: string
	count: number
}

export interface ConversationAnalyticsDataPointSchema {
	date: string
	label: string
	numberOfActiveConversation: number
	numberOfNewConversationOpened: number
}

export interface PrimaryAnalyticsResponseSchema {
	aggregateAnalytics: AggregateAnalyticsSchema
	messageAnalytics: MessageAnalyticGraphDataPointSchema[]
	linkClickAnalytics: LinkClicksGraphDataPointSchema[]
}

export interface SecondaryAnalyticsDashboardResponseSchema {
	conversationsAnalytics: ConversationAnalyticsDataPointSchema[]
	messageTypeTrafficDistributionAnalytics: MessageTypeDistributionGraphDataPointSchema[]
}

export interface CampaignAnalyticsResponseSchema {
	messagesSent: number
	messagesFailed: number
	messagesDelivered: number
	messagesUndelivered: number
	messagesRead: number
	totalMessages: number
	conversationInitiated: number
	responseRate: number
	openRate: number
	engagementRate: number
	totalLinkClicks: number
	linkClicksData: LinkClicksGraphDataPointSchema[]
}

export interface GetIntegrationResponseSchema {
	integrations: IntegrationSchema[]
	paginationMeta: PaginationMeta
}

export interface UpdateOrganizationMemberRoleByIdResponseSchema {
	isRoleUpdated: boolean
}

export interface UpdateWhatsAppBusinessAccountDetailsSchema {
	businessAccountId: string
	accessToken: string
}

export interface WhatsAppBusinessAccountDetailsSchema {
	businessAccountId: string
	accessToken: string
	webhookSecret: string
}

export interface MessageTemplateSchema {
	id: string
	category: MessageTemplateCategory
	components?: WhatsAppBusinessHSMWhatsAppHSMComponent[]
	correct_category?: string
	cta_url_link_tracking_opted_out?: boolean
	language: string
	library_template_name?: string
	message_send_ttl_seconds?: number
	name: string
	previous_category?: string
	quality_score?: TemplateMessageQualityScore
	rejected_reason?: string
	status: MessageTemplateStatus
}

export type GetMessageTemplateByIdResponseSchema = MessageTemplateSchema

export type GetAllMessageTemplatesResponseSchema = MessageTemplateSchema[]

export type PhoneNumberSchemaCodeVerificationStatus = {
	status?: string
}

export interface PhoneNumberSchema {
	verified_name: string
	display_phone_number: string
	id: string
	quality_rating: string
	code_verification_status: PhoneNumberSchemaCodeVerificationStatus
	platform_type: string
}

export type GetAllPhoneNumbersResponseSchema = PhoneNumberSchema[]

export type GetPhoneNumberByIdResponseSchema = PhoneNumberSchema

export interface UpdateUserSchema {
	name: string
	profilePicture?: string
}

export interface UpdateUserResponseSchema {
	isUpdated: boolean
}

export type MessageTemplateStatus =
	(typeof MessageTemplateStatus)[keyof typeof MessageTemplateStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageTemplateStatus = {
	APPROVED: 'APPROVED',
	REJECTED: 'REJECTED',
	PENDING: 'PENDING'
} as const

export type MessageTemplateCategory =
	(typeof MessageTemplateCategory)[keyof typeof MessageTemplateCategory]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageTemplateCategory = {
	UTILITY: 'UTILITY',
	MARKETING: 'MARKETING',
	AUTHENTICATION: 'AUTHENTICATION'
} as const

export type TemplateMessageButtonType =
	(typeof TemplateMessageButtonType)[keyof typeof TemplateMessageButtonType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TemplateMessageButtonType = {
	QUICK_REPLY: 'QUICK_REPLY',
	URL: 'URL',
	PHONE_NUMBER: 'PHONE_NUMBER',
	COPY_CODE: 'COPY_CODE'
} as const

export type MessageTemplateComponentType =
	(typeof MessageTemplateComponentType)[keyof typeof MessageTemplateComponentType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageTemplateComponentType = {
	GREETING: 'GREETING',
	HEADER: 'HEADER',
	BODY: 'BODY',
	FOOTER: 'FOOTER',
	BUTTONS: 'BUTTONS',
	CAROUSEL: 'CAROUSEL',
	LIMITED_TIME_OFFER: 'LIMITED_TIME_OFFER'
} as const

export type MessageTemplateComponentFormat =
	(typeof MessageTemplateComponentFormat)[keyof typeof MessageTemplateComponentFormat]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageTemplateComponentFormat = {
	TEXT: 'TEXT',
	IMAGE: 'IMAGE',
	DOCUMENT: 'DOCUMENT',
	VIDEO: 'VIDEO',
	LOCATION: 'LOCATION'
} as const

export interface TemplateMessageComponentButton {
	type?: TemplateMessageButtonType
	text?: string
	phone_number?: string
	example?: string[]
	url?: string
}

export interface TemplateMessageComponentExample {
	header_handle?: string[]
	header_text?: string[]
	body_text?: string[][]
}

export type WhatsAppBusinessHSMWhatsAppHSMComponentCardsItem = { [key: string]: unknown }

export type WhatsAppBusinessHSMWhatsAppHSMComponentLimitedTimeOffer = { [key: string]: unknown }

export interface WhatsAppBusinessHSMWhatsAppHSMComponent {
	add_security_recommendation?: boolean
	buttons?: TemplateMessageComponentButton[]
	cards?: WhatsAppBusinessHSMWhatsAppHSMComponentCardsItem[]
	code_expiration_minutes?: number
	example?: TemplateMessageComponentExample
	format?: MessageTemplateComponentFormat
	limited_time_offer?: WhatsAppBusinessHSMWhatsAppHSMComponentLimitedTimeOffer
	text?: string
	type?: MessageTemplateComponentType
}

export interface TemplateMessageQualityScore {
	date?: number
	reasons?: string[]
	score?: number
}

export interface NotificationSchema {
	uniqueId: string
	title: string
	description: string
	type: string
	ctaUrl?: string
	createdAt: string
	read: boolean
	organizationId?: string
}

export interface GetUserNotificationsResponseSchema {
	unreadCount: number
	notifications: NotificationSchema[]
	paginationMeta: PaginationMeta
}

export type AiChatMessageRoleEnum =
	(typeof AiChatMessageRoleEnum)[keyof typeof AiChatMessageRoleEnum]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AiChatMessageRoleEnum = {
	User: 'User',
	System: 'System',
	Assistant: 'Assistant',
	Data: 'Data'
} as const

export interface AiChatMessageSchema {
	uniqueId: string
	createdAt: string
	role: AiChatMessageRoleEnum
	content: string
}

export interface AiChatSchema {
	uniqueId: string
	createdAt: string
	title: string
	description?: string
}

export interface GetAiChatByIdResponseSchema {
	chat: AiChatSchema
}

export interface GetAiChatMessagesResponseSchema {
	messages: AiChatMessageSchema[]
	paginationMeta: PaginationMeta
}

export interface AiChatMessageVoteCreateSchema {
	type?: AiChatMessageVoteEnum
	messageId: string
}

export interface CreateAiChatMessageVoteResponseSchema {
	vote: AiChatMessageVoteSchema
}

export interface GetAiChatVotesResponseSchema {
	votes: AiChatMessageVoteSchema[]
	paginationMeta: PaginationMeta
}

export interface AiChatMessageVoteSchema {
	uniqueId: string
	messageId: string
	vote: AiChatMessageVoteEnum
	createdAt: string
}

export interface GetAiChatsResponseSchema {
	chats: AiChatSchema[]
	paginationMeta: PaginationMeta
}

export interface AiChatQuerySchema {
	query: string
}

export interface AiConfigurationDetailsSchema {
	isEnabled?: boolean
	model: AiModelEnum
}

export interface UpdateAIConfigurationDetailsSchema {
	isEnabled?: boolean
	model: AiModelEnum
	apiKey: string
}

export interface FullAiConfiguration {
	apiKey: string
	model: AiModelEnum
	isEnabled: boolean
}

export interface GetAiConfigurationResponseSchema {
	aiConfiguration: FullAiConfiguration
}

export interface SegmentationRecommendation {
	lists: ContactListSchema[]
	tags: TagSchema[]
}

export interface GetSegmentationRecommendationsResponse {
	recommendations: SegmentationRecommendation[]
}

export interface GetResponseSuggestionsResponse {
	suggestions: string[]
}

export interface GetOrganizationInviteBySlugResponseSchema {
	invite: OrganizationMemberInviteSchema
}

export interface AcceptOrganizationInviteResponseSchema {
	token: string
}

export interface NotFoundErrorResponseSchema {
	message: string
}

export interface InternalServerErrorResponseSchema {
	message: string
}

export interface RateLimitErrorResponseSchema {
	message: string
	remaining: number
	reset: number
}

export interface BadRequestErrorResponseSchema {
	message: string
}

export interface UnauthorizedErrorResponseSchema {
	message: string
}

export type GetHealthCheck200 = {
	data?: boolean
}

export type GetUserNotificationsParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * sorting order
	 */
	sortBy?: OrderEnum
}

export type SwitchOrganizationBody = {
	organizationId?: string
}

export type GetUserOrganizationsParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * sorting order
	 */
	sortBy?: OrderEnum
}

export type GetOrganizationRolesParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * sorting order
	 */
	sortBy?: OrderEnum
}

export type GetOrganizationTagsParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * sorting order
	 */
	sortBy?: OrderEnum
}

export type GetOrganizationInvitesParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * sorting order
	 */
	sortBy?: OrderEnum
}

export type GetOrganizationMembersParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * sorting order
	 */
	sortBy?: OrderEnum
}

export type UpdateOrganizationMemberById200 = {
	data?: UpdateOrganizationMemberByIdResponseSchema
}

export type GetContactsParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * query subscribers with a list id.
	 */
	list_id?: string
	/**
	 * order by asc or desc
	 */
	order?: OrderEnum
	/**
	 * sort by a field
	 */
	status?: string
}

export type DeleteContactsByListParams = {
	/**
	 * contact id/s to be deleted
	 */
	id: string
}

export type DeleteContactsByList200 = {
	data?: boolean
}

export type BulkImportContactsBodyOne = {
	/** The CSV file to be imported */
	file?: Blob
}

export type GetContactListsParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * order by asc or desc
	 */
	order?: OrderEnum
}

export type DeleteListById200 = {
	data?: boolean
}

export type GetCampaignsParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * order by asc or desc
	 */
	order?: OrderEnum
	/**
	 * sort by a field
	 */
	status?: CampaignStatusEnum
}

export type DeleteCampaignById200 = {
	data?: boolean
}

export type GetConversationsParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * order by asc or desc
	 */
	order?: OrderEnum
	/**
	 * sort by a field
	 */
	status?: ConversationStatusEnum
	/**
	 * query conversations with a contact id.
	 */
	contact_id?: string
	/**
	 * query conversations with a campaign id.
	 */
	campaign_id?: string
	/**
	 * query conversations with a list id.
	 */
	list_id?: string
	/**
	 * query conversations with a message id.
	 */
	message_id?: string
}

export type GetConversationMessagesParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
	/**
	 * order by asc or desc
	 */
	order?: OrderEnum
}

export type GetMessagesParams = {
	/**
	 * number of records to skip
	 */
	page?: number
	/**
	 * max number of records to return per page
	 */
	per_page?: number
	/**
	 * order by asc or desc
	 */
	order?: OrderEnum
	/**
	 * status of the message
	 */
	status?: GetMessagesStatus
	/**
	 * direction of the message
	 */
	direction?: MessageDirectionEnum
	/**
	 * query messages with a contact id.
	 */
	contact_id?: string
	/**
	 * query messages with a campaign id.
	 */
	campaign_id?: string
	/**
	 * query messages with a list id.
	 */
	list_id?: string
	/**
	 * query messages with a conversation id.
	 */
	conversation_id?: string
}

export type GetMessagesStatus = (typeof GetMessagesStatus)[keyof typeof GetMessagesStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetMessagesStatus = {
	read: 'read',
	unread: 'unread',
	sent: 'sent',
	failed: 'failed'
} as const

export type GetMessages200 = {
	messages?: MessageSchema[]
	paginationMeta?: PaginationMeta
}

export type GetIntegrationsParams = {
	/**
	 * number of records to skip
	 */
	page?: number
	/**
	 * max number of records to return per page
	 */
	per_page?: number
	/**
	 * order by asc or desc
	 */
	order?: OrderEnum
	/**
	 * status of the integration
	 */
	status?: IntegrationStatusEnum
}

export type GetPrimaryAnalyticsParams = {
	/**
	 * starting range of time span to get analytics for
	 */
	from: string
	/**
	 * ending range of time span to get analytics for
	 */
	to: string
}

export type GetSecondaryAnalyticsParams = {
	/**
	 * starting range of time span to get analytics for
	 */
	from?: string
	/**
	 * ending range of time span to get analytics for
	 */
	to?: string
}

export type GetCampaignsAnalyticsParams = {
	/**
	 * starting range of time span to get analytics for
	 */
	from?: string
	/**
	 * ending range of time span to get analytics for
	 */
	to?: string
}

export type GetAiChatsParams = {
	/**
	 * number of records to skip
	 */
	page?: number
	/**
	 * max number of records to return per page
	 */
	per_page?: number
	/**
	 * order by asc or desc
	 */
	order?: OrderEnum
	/**
	 * status of the ai chat
	 */
	status?: AiChatStatusEnum
	/**
	 * visibility of the ai chat
	 */
	visibility?: AiChatVisibilityEnum
}

export type GetAiChatMessagesParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
}

export type GetAiChatMessageVotesParams = {
	/**
	 * number of records to skip
	 */
	page: number
	/**
	 * max number of records to return per page
	 */
	per_page: number
}

export type GetAiChatSegmentRecommendationsParams = {
	/**
	 * number of records to skip
	 */
	conversationId?: number
	/**
	 * max number of records to return per page
	 */
	contactId?: number
}

export type GetConversationResponseSuggestionsParams = {
	/**
	 * number of records to skip
	 */
	conversationId: string
}

/**
 * healthcheck endpoint
 */
export const getHealthCheck = (signal?: AbortSignal) => {
	return customInstance<GetHealthCheck200>({ url: `/health-check`, method: 'GET', signal })
}

export const getGetHealthCheckQueryKey = () => {
	return [`/health-check`] as const
}

export const getGetHealthCheckQueryOptions = <
	TData = Awaited<ReturnType<typeof getHealthCheck>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthCheck>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetHealthCheckQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealthCheck>>> = ({ signal }) =>
		getHealthCheck(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getHealthCheck>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetHealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof getHealthCheck>>>
export type GetHealthCheckQueryError = unknown

export function useGetHealthCheck<
	TData = Awaited<ReturnType<typeof getHealthCheck>>,
	TError = unknown
>(options: {
	query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthCheck>>, TError, TData>> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof getHealthCheck>>,
				TError,
				Awaited<ReturnType<typeof getHealthCheck>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetHealthCheck<
	TData = Awaited<ReturnType<typeof getHealthCheck>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthCheck>>, TError, TData>> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof getHealthCheck>>,
				TError,
				Awaited<ReturnType<typeof getHealthCheck>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetHealthCheck<
	TData = Awaited<ReturnType<typeof getHealthCheck>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthCheck>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetHealthCheck<
	TData = Awaited<ReturnType<typeof getHealthCheck>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getHealthCheck>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetHealthCheckQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns the meta data
 */
export const getMetaData = (signal?: AbortSignal) => {
	return customInstance<GetMetaDataResponseSchema>({ url: `/meta-data`, method: 'GET', signal })
}

export const getGetMetaDataQueryKey = () => {
	return [`/meta-data`] as const
}

export const getGetMetaDataQueryOptions = <
	TData = Awaited<ReturnType<typeof getMetaData>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetaData>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetMetaDataQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetaData>>> = ({ signal }) =>
		getMetaData(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getMetaData>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMetaDataQueryResult = NonNullable<Awaited<ReturnType<typeof getMetaData>>>
export type GetMetaDataQueryError = unknown

export function useGetMetaData<
	TData = Awaited<ReturnType<typeof getMetaData>>,
	TError = unknown
>(options: {
	query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetaData>>, TError, TData>> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof getMetaData>>,
				TError,
				Awaited<ReturnType<typeof getMetaData>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMetaData<
	TData = Awaited<ReturnType<typeof getMetaData>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetaData>>, TError, TData>> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof getMetaData>>,
				TError,
				Awaited<ReturnType<typeof getMetaData>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMetaData<
	TData = Awaited<ReturnType<typeof getMetaData>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetaData>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMetaData<
	TData = Awaited<ReturnType<typeof getMetaData>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMetaData>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetMetaDataQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * Opens a persistent connection for real-time updates using Server-Sent Events (SSE).
The client should listen to events and process incoming messages.

 * @summary Subscribe to real-time events
 */
export const getSSEUpdates = (signal?: AbortSignal) => {
	return customInstance<string>({ url: `/events`, method: 'GET', signal })
}

export const getGetSSEUpdatesQueryKey = () => {
	return [`/events`] as const
}

export const getGetSSEUpdatesQueryOptions = <
	TData = Awaited<ReturnType<typeof getSSEUpdates>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSSEUpdates>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetSSEUpdatesQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSSEUpdates>>> = ({ signal }) =>
		getSSEUpdates(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSSEUpdates>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSSEUpdatesQueryResult = NonNullable<Awaited<ReturnType<typeof getSSEUpdates>>>
export type GetSSEUpdatesQueryError = unknown

export function useGetSSEUpdates<
	TData = Awaited<ReturnType<typeof getSSEUpdates>>,
	TError = unknown
>(options: {
	query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSSEUpdates>>, TError, TData>> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof getSSEUpdates>>,
				TError,
				Awaited<ReturnType<typeof getSSEUpdates>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSSEUpdates<
	TData = Awaited<ReturnType<typeof getSSEUpdates>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSSEUpdates>>, TError, TData>> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof getSSEUpdates>>,
				TError,
				Awaited<ReturnType<typeof getSSEUpdates>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSSEUpdates<
	TData = Awaited<ReturnType<typeof getSSEUpdates>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSSEUpdates>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Subscribe to real-time events
 */

export function useGetSSEUpdates<
	TData = Awaited<ReturnType<typeof getSSEUpdates>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getSSEUpdates>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetSSEUpdatesQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * login endpoint
 */
export const login = (loginRequestBodySchema: LoginRequestBodySchema, signal?: AbortSignal) => {
	return customInstance<LoginResponseBodySchema>({
		url: `/auth/login`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: loginRequestBodySchema,
		signal
	})
}

export const getLoginMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof login>>,
		TError,
		{ data: LoginRequestBodySchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: LoginRequestBodySchema },
	TContext
> => {
	const mutationKey = ['login']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof login>>,
		{ data: LoginRequestBodySchema }
	> = props => {
		const { data } = props ?? {}

		return login(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
export type LoginMutationBody = LoginRequestBodySchema
export type LoginMutationError = unknown

export const useLogin = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof login>>,
		TError,
		{ data: LoginRequestBodySchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: LoginRequestBodySchema },
	TContext
> => {
	const mutationOptions = getLoginMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * register endpoint
 */
export const register = (
	registerRequestBodySchema: RegisterRequestBodySchema,
	signal?: AbortSignal
) => {
	return customInstance<RegisterRequestResponseBodySchema>({
		url: `/auth/register`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: registerRequestBodySchema,
		signal
	})
}

export const getRegisterMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof register>>,
		TError,
		{ data: RegisterRequestBodySchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: RegisterRequestBodySchema },
	TContext
> => {
	const mutationKey = ['register']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof register>>,
		{ data: RegisterRequestBodySchema }
	> = props => {
		const { data } = props ?? {}

		return register(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>
export type RegisterMutationBody = RegisterRequestBodySchema
export type RegisterMutationError = unknown

export const useRegister = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof register>>,
		TError,
		{ data: RegisterRequestBodySchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof register>>,
	TError,
	{ data: RegisterRequestBodySchema },
	TContext
> => {
	const mutationOptions = getRegisterMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * verify otp endpoint
 */
export const verifyOtp = (
	verifyOtpRequestBodySchema: VerifyOtpRequestBodySchema,
	signal?: AbortSignal
) => {
	return customInstance<VerifyOtpResponseBodySchema>({
		url: `/auth/verify-email`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: verifyOtpRequestBodySchema,
		signal
	})
}

export const getVerifyOtpMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof verifyOtp>>,
		TError,
		{ data: VerifyOtpRequestBodySchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof verifyOtp>>,
	TError,
	{ data: VerifyOtpRequestBodySchema },
	TContext
> => {
	const mutationKey = ['verifyOtp']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof verifyOtp>>,
		{ data: VerifyOtpRequestBodySchema }
	> = props => {
		const { data } = props ?? {}

		return verifyOtp(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type VerifyOtpMutationResult = NonNullable<Awaited<ReturnType<typeof verifyOtp>>>
export type VerifyOtpMutationBody = VerifyOtpRequestBodySchema
export type VerifyOtpMutationError = unknown

export const useVerifyOtp = <TError = unknown, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof verifyOtp>>,
		TError,
		{ data: VerifyOtpRequestBodySchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof verifyOtp>>,
	TError,
	{ data: VerifyOtpRequestBodySchema },
	TContext
> => {
	const mutationOptions = getVerifyOtpMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * regenerates the API key
 */
export const regenerateApiKey = (signal?: AbortSignal) => {
	return customInstance<RegenerateApiKeyResponseSchema>({
		url: `/auth/api-keys/regenerate`,
		method: 'GET',
		signal
	})
}

export const getRegenerateApiKeyQueryKey = () => {
	return [`/auth/api-keys/regenerate`] as const
}

export const getRegenerateApiKeyQueryOptions = <
	TData = Awaited<ReturnType<typeof regenerateApiKey>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof regenerateApiKey>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getRegenerateApiKeyQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof regenerateApiKey>>> = ({ signal }) =>
		regenerateApiKey(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof regenerateApiKey>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type RegenerateApiKeyQueryResult = NonNullable<Awaited<ReturnType<typeof regenerateApiKey>>>
export type RegenerateApiKeyQueryError = unknown

export function useRegenerateApiKey<
	TData = Awaited<ReturnType<typeof regenerateApiKey>>,
	TError = unknown
>(options: {
	query: Partial<UseQueryOptions<Awaited<ReturnType<typeof regenerateApiKey>>, TError, TData>> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof regenerateApiKey>>,
				TError,
				Awaited<ReturnType<typeof regenerateApiKey>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRegenerateApiKey<
	TData = Awaited<ReturnType<typeof regenerateApiKey>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof regenerateApiKey>>, TError, TData>> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof regenerateApiKey>>,
				TError,
				Awaited<ReturnType<typeof regenerateApiKey>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useRegenerateApiKey<
	TData = Awaited<ReturnType<typeof regenerateApiKey>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof regenerateApiKey>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useRegenerateApiKey<
	TData = Awaited<ReturnType<typeof regenerateApiKey>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof regenerateApiKey>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getRegenerateApiKeyQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * join an organization
 */
export const joinOrganization = (
	joinOrganizationRequestBodySchema: JoinOrganizationRequestBodySchema,
	signal?: AbortSignal
) => {
	return customInstance<JoinOrganizationResponseBodySchema>({
		url: `/auth/join-organization`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: joinOrganizationRequestBodySchema,
		signal
	})
}

export const getJoinOrganizationMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof joinOrganization>>,
		TError,
		{ data: JoinOrganizationRequestBodySchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof joinOrganization>>,
	TError,
	{ data: JoinOrganizationRequestBodySchema },
	TContext
> => {
	const mutationKey = ['joinOrganization']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof joinOrganization>>,
		{ data: JoinOrganizationRequestBodySchema }
	> = props => {
		const { data } = props ?? {}

		return joinOrganization(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type JoinOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof joinOrganization>>
>
export type JoinOrganizationMutationBody = JoinOrganizationRequestBodySchema
export type JoinOrganizationMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useJoinOrganization = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof joinOrganization>>,
		TError,
		{ data: JoinOrganizationRequestBodySchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof joinOrganization>>,
	TError,
	{ data: JoinOrganizationRequestBodySchema },
	TContext
> => {
	const mutationOptions = getJoinOrganizationMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns the user object
 */
export const getUser = (signal?: AbortSignal) => {
	return customInstance<GetUserResponseSchema>({ url: `/user`, method: 'GET', signal })
}

export const getGetUserQueryKey = () => {
	return [`/user`] as const
}

export const getGetUserQueryOptions = <
	TData = Awaited<ReturnType<typeof getUser>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) =>
		getUser(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getUser>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetUser<
	TData = Awaited<ReturnType<typeof getUser>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options: {
	query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof getUser>>,
				TError,
				Awaited<ReturnType<typeof getUser>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUser<
	TData = Awaited<ReturnType<typeof getUser>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof getUser>>,
				TError,
				Awaited<ReturnType<typeof getUser>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUser<
	TData = Awaited<ReturnType<typeof getUser>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUser<
	TData = Awaited<ReturnType<typeof getUser>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetUserQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * update user info
 */
export const updateUser = (updateUserSchema: UpdateUserSchema, signal?: AbortSignal) => {
	return customInstance<UpdateUserResponseSchema>({
		url: `/user`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: updateUserSchema,
		signal
	})
}

export const getUpdateUserMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateUser>>,
		TError,
		{ data: UpdateUserSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateUser>>,
	TError,
	{ data: UpdateUserSchema },
	TContext
> => {
	const mutationKey = ['updateUser']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateUser>>,
		{ data: UpdateUserSchema }
	> = props => {
		const { data } = props ?? {}

		return updateUser(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
export type UpdateUserMutationBody = UpdateUserSchema
export type UpdateUserMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateUser = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateUser>>,
		TError,
		{ data: UpdateUserSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateUser>>,
	TError,
	{ data: UpdateUserSchema },
	TContext
> => {
	const mutationOptions = getUpdateUserMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all notifications
 */
export const getUserNotifications = (params: GetUserNotificationsParams, signal?: AbortSignal) => {
	return customInstance<GetUserNotificationsResponseSchema>({
		url: `/user/notifications`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetUserNotificationsQueryKey = (params: GetUserNotificationsParams) => {
	return [`/user/notifications`, ...(params ? [params] : [])] as const
}

export const getGetUserNotificationsQueryOptions = <
	TData = Awaited<ReturnType<typeof getUserNotifications>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserNotificationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserNotifications>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetUserNotificationsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserNotifications>>> = ({ signal }) =>
		getUserNotifications(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getUserNotifications>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserNotificationsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUserNotifications>>
>
export type GetUserNotificationsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetUserNotifications<
	TData = Awaited<ReturnType<typeof getUserNotifications>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserNotificationsParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserNotifications>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getUserNotifications>>,
					TError,
					Awaited<ReturnType<typeof getUserNotifications>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserNotifications<
	TData = Awaited<ReturnType<typeof getUserNotifications>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserNotificationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserNotifications>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getUserNotifications>>,
					TError,
					Awaited<ReturnType<typeof getUserNotifications>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserNotifications<
	TData = Awaited<ReturnType<typeof getUserNotifications>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserNotificationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserNotifications>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUserNotifications<
	TData = Awaited<ReturnType<typeof getUserNotifications>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserNotificationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserNotifications>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetUserNotificationsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all feature flags
 */
export const getUserFeatureFlags = (signal?: AbortSignal) => {
	return customInstance<GetFeatureFlagsResponseSchema>({
		url: `/system/feature-flags`,
		method: 'GET',
		signal
	})
}

export const getGetUserFeatureFlagsQueryKey = () => {
	return [`/system/feature-flags`] as const
}

export const getGetUserFeatureFlagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getUserFeatureFlags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeatureFlags>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetUserFeatureFlagsQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserFeatureFlags>>> = ({ signal }) =>
		getUserFeatureFlags(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getUserFeatureFlags>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserFeatureFlagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUserFeatureFlags>>
>
export type GetUserFeatureFlagsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetUserFeatureFlags<
	TData = Awaited<ReturnType<typeof getUserFeatureFlags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options: {
	query: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof getUserFeatureFlags>>, TError, TData>
	> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof getUserFeatureFlags>>,
				TError,
				Awaited<ReturnType<typeof getUserFeatureFlags>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserFeatureFlags<
	TData = Awaited<ReturnType<typeof getUserFeatureFlags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof getUserFeatureFlags>>, TError, TData>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof getUserFeatureFlags>>,
				TError,
				Awaited<ReturnType<typeof getUserFeatureFlags>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserFeatureFlags<
	TData = Awaited<ReturnType<typeof getUserFeatureFlags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeatureFlags>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUserFeatureFlags<
	TData = Awaited<ReturnType<typeof getUserFeatureFlags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserFeatureFlags>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetUserFeatureFlagsQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all api keys
 */
export const getApiKeys = (signal?: AbortSignal) => {
	return customInstance<GetApiKeysResponseSchema>({
		url: `/auth/api-keys`,
		method: 'GET',
		signal
	})
}

export const getGetApiKeysQueryKey = () => {
	return [`/auth/api-keys`] as const
}

export const getGetApiKeysQueryOptions = <
	TData = Awaited<ReturnType<typeof getApiKeys>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKeys>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetApiKeysQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiKeys>>> = ({ signal }) =>
		getApiKeys(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getApiKeys>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetApiKeysQueryResult = NonNullable<Awaited<ReturnType<typeof getApiKeys>>>
export type GetApiKeysQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetApiKeys<
	TData = Awaited<ReturnType<typeof getApiKeys>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options: {
	query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKeys>>, TError, TData>> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof getApiKeys>>,
				TError,
				Awaited<ReturnType<typeof getApiKeys>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiKeys<
	TData = Awaited<ReturnType<typeof getApiKeys>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKeys>>, TError, TData>> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof getApiKeys>>,
				TError,
				Awaited<ReturnType<typeof getApiKeys>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetApiKeys<
	TData = Awaited<ReturnType<typeof getApiKeys>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKeys>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetApiKeys<
	TData = Awaited<ReturnType<typeof getApiKeys>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiKeys>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetApiKeysQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * switch user organization
 */
export const switchOrganization = (
	switchOrganizationBody: SwitchOrganizationBody,
	signal?: AbortSignal
) => {
	return customInstance<SwitchOrganizationResponseSchema>({
		url: `/auth/switch`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: switchOrganizationBody,
		signal
	})
}

export const getSwitchOrganizationMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof switchOrganization>>,
		TError,
		{ data: SwitchOrganizationBody },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof switchOrganization>>,
	TError,
	{ data: SwitchOrganizationBody },
	TContext
> => {
	const mutationKey = ['switchOrganization']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof switchOrganization>>,
		{ data: SwitchOrganizationBody }
	> = props => {
		const { data } = props ?? {}

		return switchOrganization(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type SwitchOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof switchOrganization>>
>
export type SwitchOrganizationMutationBody = SwitchOrganizationBody
export type SwitchOrganizationMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useSwitchOrganization = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof switchOrganization>>,
		TError,
		{ data: SwitchOrganizationBody },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof switchOrganization>>,
	TError,
	{ data: SwitchOrganizationBody },
	TContext
> => {
	const mutationOptions = getSwitchOrganizationMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * create a new organization
 */
export const createOrganization = (
	newOrganizationSchema: NewOrganizationSchema,
	signal?: AbortSignal
) => {
	return customInstance<CreateNewOrganizationResponseSchema>({
		url: `/organization`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: newOrganizationSchema,
		signal
	})
}

export const getCreateOrganizationMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createOrganization>>,
		TError,
		{ data: NewOrganizationSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof createOrganization>>,
	TError,
	{ data: NewOrganizationSchema },
	TContext
> => {
	const mutationKey = ['createOrganization']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createOrganization>>,
		{ data: NewOrganizationSchema }
	> = props => {
		const { data } = props ?? {}

		return createOrganization(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type CreateOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof createOrganization>>
>
export type CreateOrganizationMutationBody = NewOrganizationSchema
export type CreateOrganizationMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useCreateOrganization = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createOrganization>>,
		TError,
		{ data: NewOrganizationSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof createOrganization>>,
	TError,
	{ data: NewOrganizationSchema },
	TContext
> => {
	const mutationOptions = getCreateOrganizationMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all organizations
 */
export const getUserOrganizations = (params: GetUserOrganizationsParams, signal?: AbortSignal) => {
	return customInstance<GetOrganizationsResponseSchema>({
		url: `/organization`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetUserOrganizationsQueryKey = (params: GetUserOrganizationsParams) => {
	return [`/organization`, ...(params ? [params] : [])] as const
}

export const getGetUserOrganizationsQueryOptions = <
	TData = Awaited<ReturnType<typeof getUserOrganizations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserOrganizationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserOrganizations>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetUserOrganizationsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserOrganizations>>> = ({ signal }) =>
		getUserOrganizations(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getUserOrganizations>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserOrganizationsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUserOrganizations>>
>
export type GetUserOrganizationsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetUserOrganizations<
	TData = Awaited<ReturnType<typeof getUserOrganizations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserOrganizationsParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserOrganizations>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getUserOrganizations>>,
					TError,
					Awaited<ReturnType<typeof getUserOrganizations>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserOrganizations<
	TData = Awaited<ReturnType<typeof getUserOrganizations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserOrganizationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserOrganizations>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getUserOrganizations>>,
					TError,
					Awaited<ReturnType<typeof getUserOrganizations>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserOrganizations<
	TData = Awaited<ReturnType<typeof getUserOrganizations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserOrganizationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserOrganizations>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUserOrganizations<
	TData = Awaited<ReturnType<typeof getUserOrganizations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetUserOrganizationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getUserOrganizations>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetUserOrganizationsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns the organization object
 */
export const getOrganizationById = (id: string, signal?: AbortSignal) => {
	return customInstance<GetOrganizationByIdResponseSchema>({
		url: `/organization/${id}`,
		method: 'GET',
		signal
	})
}

export const getGetOrganizationByIdQueryKey = (id: string) => {
	return [`/organization/${id}`] as const
}

export const getGetOrganizationByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getOrganizationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationById>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetOrganizationByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrganizationById>>> = ({ signal }) =>
		getOrganizationById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getOrganizationById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOrganizationByIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganizationById>>
>
export type GetOrganizationByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetOrganizationById<
	TData = Awaited<ReturnType<typeof getOrganizationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationById>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationById>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationById<
	TData = Awaited<ReturnType<typeof getOrganizationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationById>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationById>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationById<
	TData = Awaited<ReturnType<typeof getOrganizationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetOrganizationById<
	TData = Awaited<ReturnType<typeof getOrganizationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetOrganizationByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * update an organization
 */
export const updateOrganization = (
	id: string,
	updateOrganizationSchema: UpdateOrganizationSchema,
	signal?: AbortSignal
) => {
	return customInstance<UpdateOrganizationByIdResponseSchema>({
		url: `/organization/${id}`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: updateOrganizationSchema,
		signal
	})
}

export const getUpdateOrganizationMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateOrganization>>,
		TError,
		{ id: string; data: UpdateOrganizationSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateOrganization>>,
	TError,
	{ id: string; data: UpdateOrganizationSchema },
	TContext
> => {
	const mutationKey = ['updateOrganization']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateOrganization>>,
		{ id: string; data: UpdateOrganizationSchema }
	> = props => {
		const { id, data } = props ?? {}

		return updateOrganization(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateOrganizationMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateOrganization>>
>
export type UpdateOrganizationMutationBody = UpdateOrganizationSchema
export type UpdateOrganizationMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateOrganization = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateOrganization>>,
		TError,
		{ id: string; data: UpdateOrganizationSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateOrganization>>,
	TError,
	{ id: string; data: UpdateOrganizationSchema },
	TContext
> => {
	const mutationOptions = getUpdateOrganizationMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns the full ai configuration with api key
 */
export const getAIConfiguration = (signal?: AbortSignal) => {
	return customInstance<GetAiConfigurationResponseSchema>({
		url: `/organization/ai-configuration`,
		method: 'GET',
		signal
	})
}

export const getGetAIConfigurationQueryKey = () => {
	return [`/organization/ai-configuration`] as const
}

export const getGetAIConfigurationQueryOptions = <
	TData = Awaited<ReturnType<typeof getAIConfiguration>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAIConfiguration>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetAIConfigurationQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAIConfiguration>>> = ({ signal }) =>
		getAIConfiguration(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAIConfiguration>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAIConfigurationQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAIConfiguration>>
>
export type GetAIConfigurationQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetAIConfiguration<
	TData = Awaited<ReturnType<typeof getAIConfiguration>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options: {
	query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAIConfiguration>>, TError, TData>> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof getAIConfiguration>>,
				TError,
				Awaited<ReturnType<typeof getAIConfiguration>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAIConfiguration<
	TData = Awaited<ReturnType<typeof getAIConfiguration>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof getAIConfiguration>>, TError, TData>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof getAIConfiguration>>,
				TError,
				Awaited<ReturnType<typeof getAIConfiguration>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAIConfiguration<
	TData = Awaited<ReturnType<typeof getAIConfiguration>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAIConfiguration>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAIConfiguration<
	TData = Awaited<ReturnType<typeof getAIConfiguration>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAIConfiguration>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetAIConfigurationQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all organization roles
 */
export const getOrganizationRoles = (params: GetOrganizationRolesParams, signal?: AbortSignal) => {
	return customInstance<GetOrganizationRolesResponseSchema>({
		url: `/rbac/roles`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetOrganizationRolesQueryKey = (params: GetOrganizationRolesParams) => {
	return [`/rbac/roles`, ...(params ? [params] : [])] as const
}

export const getGetOrganizationRolesQueryOptions = <
	TData = Awaited<ReturnType<typeof getOrganizationRoles>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationRolesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoles>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetOrganizationRolesQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrganizationRoles>>> = ({ signal }) =>
		getOrganizationRoles(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getOrganizationRoles>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOrganizationRolesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganizationRoles>>
>
export type GetOrganizationRolesQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetOrganizationRoles<
	TData = Awaited<ReturnType<typeof getOrganizationRoles>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationRolesParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoles>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationRoles>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationRoles>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationRoles<
	TData = Awaited<ReturnType<typeof getOrganizationRoles>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationRolesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoles>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationRoles>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationRoles>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationRoles<
	TData = Awaited<ReturnType<typeof getOrganizationRoles>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationRolesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoles>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetOrganizationRoles<
	TData = Awaited<ReturnType<typeof getOrganizationRoles>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationRolesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoles>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetOrganizationRolesQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * create a new organization role
 */
export const createOrganizationRole = (
	newOrganizationRoleSchema: NewOrganizationRoleSchema,
	signal?: AbortSignal
) => {
	return customInstance<CreateNewRoleResponseSchema>({
		url: `/rbac/roles`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: newOrganizationRoleSchema,
		signal
	})
}

export const getCreateOrganizationRoleMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createOrganizationRole>>,
		TError,
		{ data: NewOrganizationRoleSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof createOrganizationRole>>,
	TError,
	{ data: NewOrganizationRoleSchema },
	TContext
> => {
	const mutationKey = ['createOrganizationRole']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createOrganizationRole>>,
		{ data: NewOrganizationRoleSchema }
	> = props => {
		const { data } = props ?? {}

		return createOrganizationRole(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type CreateOrganizationRoleMutationResult = NonNullable<
	Awaited<ReturnType<typeof createOrganizationRole>>
>
export type CreateOrganizationRoleMutationBody = NewOrganizationRoleSchema
export type CreateOrganizationRoleMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useCreateOrganizationRole = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createOrganizationRole>>,
		TError,
		{ data: NewOrganizationRoleSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof createOrganizationRole>>,
	TError,
	{ data: NewOrganizationRoleSchema },
	TContext
> => {
	const mutationOptions = getCreateOrganizationRoleMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns a single organization role
 */
export const getOrganizationRoleById = (id: string, signal?: AbortSignal) => {
	return customInstance<GetRoleByIdResponseSchema>({
		url: `/rbac/roles/${id}`,
		method: 'GET',
		signal
	})
}

export const getGetOrganizationRoleByIdQueryKey = (id: string) => {
	return [`/rbac/roles/${id}`] as const
}

export const getGetOrganizationRoleByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getOrganizationRoleById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoleById>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetOrganizationRoleByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrganizationRoleById>>> = ({
		signal
	}) => getOrganizationRoleById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getOrganizationRoleById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOrganizationRoleByIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganizationRoleById>>
>
export type GetOrganizationRoleByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetOrganizationRoleById<
	TData = Awaited<ReturnType<typeof getOrganizationRoleById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoleById>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationRoleById>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationRoleById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationRoleById<
	TData = Awaited<ReturnType<typeof getOrganizationRoleById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoleById>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationRoleById>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationRoleById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationRoleById<
	TData = Awaited<ReturnType<typeof getOrganizationRoleById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoleById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetOrganizationRoleById<
	TData = Awaited<ReturnType<typeof getOrganizationRoleById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationRoleById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetOrganizationRoleByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * updates a organization role
 */
export const updateOrganizationRoleById = (
	id: string,
	roleUpdateSchema: RoleUpdateSchema,
	signal?: AbortSignal
) => {
	return customInstance<UpdateRoleByIdResponseSchema>({
		url: `/rbac/roles/${id}`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: roleUpdateSchema,
		signal
	})
}

export const getUpdateOrganizationRoleByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateOrganizationRoleById>>,
		TError,
		{ id: string; data: RoleUpdateSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateOrganizationRoleById>>,
	TError,
	{ id: string; data: RoleUpdateSchema },
	TContext
> => {
	const mutationKey = ['updateOrganizationRoleById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateOrganizationRoleById>>,
		{ id: string; data: RoleUpdateSchema }
	> = props => {
		const { id, data } = props ?? {}

		return updateOrganizationRoleById(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateOrganizationRoleByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateOrganizationRoleById>>
>
export type UpdateOrganizationRoleByIdMutationBody = RoleUpdateSchema
export type UpdateOrganizationRoleByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateOrganizationRoleById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateOrganizationRoleById>>,
		TError,
		{ id: string; data: RoleUpdateSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateOrganizationRoleById>>,
	TError,
	{ id: string; data: RoleUpdateSchema },
	TContext
> => {
	const mutationOptions = getUpdateOrganizationRoleByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * delete an organization role
 */
export const deleteOrganizationRoleById = (id: string) => {
	return customInstance<DeleteRoleByIdResponseSchema>({
		url: `/rbac/roles/${id}`,
		method: 'DELETE'
	})
}

export const getDeleteOrganizationRoleByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteOrganizationRoleById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteOrganizationRoleById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['deleteOrganizationRoleById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteOrganizationRoleById>>,
		{ id: string }
	> = props => {
		const { id } = props ?? {}

		return deleteOrganizationRoleById(id)
	}

	return { mutationFn, ...mutationOptions }
}

export type DeleteOrganizationRoleByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteOrganizationRoleById>>
>

export type DeleteOrganizationRoleByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useDeleteOrganizationRoleById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteOrganizationRoleById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteOrganizationRoleById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getDeleteOrganizationRoleByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all organization tags
 */
export const getOrganizationTags = (params: GetOrganizationTagsParams, signal?: AbortSignal) => {
	return customInstance<GetOrganizationTagsResponseSchema>({
		url: `/organization/tags`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetOrganizationTagsQueryKey = (params: GetOrganizationTagsParams) => {
	return [`/organization/tags`, ...(params ? [params] : [])] as const
}

export const getGetOrganizationTagsQueryOptions = <
	TData = Awaited<ReturnType<typeof getOrganizationTags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationTagsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationTags>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetOrganizationTagsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrganizationTags>>> = ({ signal }) =>
		getOrganizationTags(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getOrganizationTags>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOrganizationTagsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganizationTags>>
>
export type GetOrganizationTagsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetOrganizationTags<
	TData = Awaited<ReturnType<typeof getOrganizationTags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationTagsParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationTags>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationTags>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationTags>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationTags<
	TData = Awaited<ReturnType<typeof getOrganizationTags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationTagsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationTags>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationTags>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationTags>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationTags<
	TData = Awaited<ReturnType<typeof getOrganizationTags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationTagsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationTags>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetOrganizationTags<
	TData = Awaited<ReturnType<typeof getOrganizationTags>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationTagsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationTags>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetOrganizationTagsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * create a new organization tag
 */
export const createOrganizationTag = (
	newOrganizationTagSchema: NewOrganizationTagSchema,
	signal?: AbortSignal
) => {
	return customInstance<CreateNewOrganizationTagResponseSchema>({
		url: `/organization/tags`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: newOrganizationTagSchema,
		signal
	})
}

export const getCreateOrganizationTagMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createOrganizationTag>>,
		TError,
		{ data: NewOrganizationTagSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof createOrganizationTag>>,
	TError,
	{ data: NewOrganizationTagSchema },
	TContext
> => {
	const mutationKey = ['createOrganizationTag']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createOrganizationTag>>,
		{ data: NewOrganizationTagSchema }
	> = props => {
		const { data } = props ?? {}

		return createOrganizationTag(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type CreateOrganizationTagMutationResult = NonNullable<
	Awaited<ReturnType<typeof createOrganizationTag>>
>
export type CreateOrganizationTagMutationBody = NewOrganizationTagSchema
export type CreateOrganizationTagMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useCreateOrganizationTag = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createOrganizationTag>>,
		TError,
		{ data: NewOrganizationTagSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof createOrganizationTag>>,
	TError,
	{ data: NewOrganizationTagSchema },
	TContext
> => {
	const mutationOptions = getCreateOrganizationTagMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all organization invites
 */
export const getOrganizationInvites = (
	params: GetOrganizationInvitesParams,
	signal?: AbortSignal
) => {
	return customInstance<GetOrganizationMemberInvitesResponseSchema>({
		url: `/organization/invites`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetOrganizationInvitesQueryKey = (params: GetOrganizationInvitesParams) => {
	return [`/organization/invites`, ...(params ? [params] : [])] as const
}

export const getGetOrganizationInvitesQueryOptions = <
	TData = Awaited<ReturnType<typeof getOrganizationInvites>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationInvitesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInvites>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetOrganizationInvitesQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrganizationInvites>>> = ({
		signal
	}) => getOrganizationInvites(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getOrganizationInvites>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOrganizationInvitesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganizationInvites>>
>
export type GetOrganizationInvitesQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetOrganizationInvites<
	TData = Awaited<ReturnType<typeof getOrganizationInvites>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationInvitesParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInvites>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationInvites>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationInvites>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationInvites<
	TData = Awaited<ReturnType<typeof getOrganizationInvites>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationInvitesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInvites>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationInvites>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationInvites>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationInvites<
	TData = Awaited<ReturnType<typeof getOrganizationInvites>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationInvitesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInvites>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetOrganizationInvites<
	TData = Awaited<ReturnType<typeof getOrganizationInvites>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationInvitesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInvites>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetOrganizationInvitesQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * create a new organization invite
 */
export const createOrganizationInvite = (
	createNewOrganizationInviteSchema: CreateNewOrganizationInviteSchema,
	signal?: AbortSignal
) => {
	return customInstance<CreateInviteResponseSchema>({
		url: `/organization/invites`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: createNewOrganizationInviteSchema,
		signal
	})
}

export const getCreateOrganizationInviteMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createOrganizationInvite>>,
		TError,
		{ data: CreateNewOrganizationInviteSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof createOrganizationInvite>>,
	TError,
	{ data: CreateNewOrganizationInviteSchema },
	TContext
> => {
	const mutationKey = ['createOrganizationInvite']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createOrganizationInvite>>,
		{ data: CreateNewOrganizationInviteSchema }
	> = props => {
		const { data } = props ?? {}

		return createOrganizationInvite(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type CreateOrganizationInviteMutationResult = NonNullable<
	Awaited<ReturnType<typeof createOrganizationInvite>>
>
export type CreateOrganizationInviteMutationBody = CreateNewOrganizationInviteSchema
export type CreateOrganizationInviteMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useCreateOrganizationInvite = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createOrganizationInvite>>,
		TError,
		{ data: CreateNewOrganizationInviteSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof createOrganizationInvite>>,
	TError,
	{ data: CreateNewOrganizationInviteSchema },
	TContext
> => {
	const mutationOptions = getCreateOrganizationInviteMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns a single organization invite
 */
export const getOrganizationInviteBySlug = (slug: string, signal?: AbortSignal) => {
	return customInstance<GetOrganizationInviteBySlugResponseSchema>({
		url: `/organization/invite/${slug}`,
		method: 'GET',
		signal
	})
}

export const getGetOrganizationInviteBySlugQueryKey = (slug: string) => {
	return [`/organization/invite/${slug}`] as const
}

export const getGetOrganizationInviteBySlugQueryOptions = <
	TData = Awaited<ReturnType<typeof getOrganizationInviteBySlug>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	slug: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInviteBySlug>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetOrganizationInviteBySlugQueryKey(slug)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrganizationInviteBySlug>>> = ({
		signal
	}) => getOrganizationInviteBySlug(slug, signal)

	return { queryKey, queryFn, enabled: !!slug, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getOrganizationInviteBySlug>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOrganizationInviteBySlugQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganizationInviteBySlug>>
>
export type GetOrganizationInviteBySlugQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetOrganizationInviteBySlug<
	TData = Awaited<ReturnType<typeof getOrganizationInviteBySlug>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	slug: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInviteBySlug>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationInviteBySlug>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationInviteBySlug>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationInviteBySlug<
	TData = Awaited<ReturnType<typeof getOrganizationInviteBySlug>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	slug: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInviteBySlug>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationInviteBySlug>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationInviteBySlug>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationInviteBySlug<
	TData = Awaited<ReturnType<typeof getOrganizationInviteBySlug>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	slug: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInviteBySlug>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetOrganizationInviteBySlug<
	TData = Awaited<ReturnType<typeof getOrganizationInviteBySlug>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	slug: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationInviteBySlug>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetOrganizationInviteBySlugQueryOptions(slug, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * accept an organization invite
 */
export const acceptOrganizationInvite = (slug: string, signal?: AbortSignal) => {
	return customInstance<AcceptOrganizationInviteResponseSchema>({
		url: `/organization/invite/${slug}/accept`,
		method: 'POST',
		signal
	})
}

export const getAcceptOrganizationInviteMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof acceptOrganizationInvite>>,
		TError,
		{ slug: string },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof acceptOrganizationInvite>>,
	TError,
	{ slug: string },
	TContext
> => {
	const mutationKey = ['acceptOrganizationInvite']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof acceptOrganizationInvite>>,
		{ slug: string }
	> = props => {
		const { slug } = props ?? {}

		return acceptOrganizationInvite(slug)
	}

	return { mutationFn, ...mutationOptions }
}

export type AcceptOrganizationInviteMutationResult = NonNullable<
	Awaited<ReturnType<typeof acceptOrganizationInvite>>
>

export type AcceptOrganizationInviteMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useAcceptOrganizationInvite = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof acceptOrganizationInvite>>,
		TError,
		{ slug: string },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof acceptOrganizationInvite>>,
	TError,
	{ slug: string },
	TContext
> => {
	const mutationOptions = getAcceptOrganizationInviteMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all organization members
 */
export const getOrganizationMembers = (
	params: GetOrganizationMembersParams,
	signal?: AbortSignal
) => {
	return customInstance<GetOrganizationMembersResponseSchema>({
		url: `/organization/members`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetOrganizationMembersQueryKey = (params: GetOrganizationMembersParams) => {
	return [`/organization/members`, ...(params ? [params] : [])] as const
}

export const getGetOrganizationMembersQueryOptions = <
	TData = Awaited<ReturnType<typeof getOrganizationMembers>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationMembersParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMembers>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetOrganizationMembersQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrganizationMembers>>> = ({
		signal
	}) => getOrganizationMembers(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getOrganizationMembers>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOrganizationMembersQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganizationMembers>>
>
export type GetOrganizationMembersQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetOrganizationMembers<
	TData = Awaited<ReturnType<typeof getOrganizationMembers>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationMembersParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMembers>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationMembers>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationMembers>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationMembers<
	TData = Awaited<ReturnType<typeof getOrganizationMembers>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationMembersParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMembers>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationMembers>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationMembers>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationMembers<
	TData = Awaited<ReturnType<typeof getOrganizationMembers>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationMembersParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMembers>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetOrganizationMembers<
	TData = Awaited<ReturnType<typeof getOrganizationMembers>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetOrganizationMembersParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMembers>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetOrganizationMembersQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns a single organization member
 */
export const getOrganizationMemberById = (id: string, signal?: AbortSignal) => {
	return customInstance<GetOrganizationMemberByIdResponseSchema>({
		url: `/organization/members/${id}`,
		method: 'GET',
		signal
	})
}

export const getGetOrganizationMemberByIdQueryKey = (id: string) => {
	return [`/organization/members/${id}`] as const
}

export const getGetOrganizationMemberByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getOrganizationMemberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMemberById>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetOrganizationMemberByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrganizationMemberById>>> = ({
		signal
	}) => getOrganizationMemberById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getOrganizationMemberById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOrganizationMemberByIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getOrganizationMemberById>>
>
export type GetOrganizationMemberByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetOrganizationMemberById<
	TData = Awaited<ReturnType<typeof getOrganizationMemberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMemberById>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationMemberById>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationMemberById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationMemberById<
	TData = Awaited<ReturnType<typeof getOrganizationMemberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMemberById>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getOrganizationMemberById>>,
					TError,
					Awaited<ReturnType<typeof getOrganizationMemberById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrganizationMemberById<
	TData = Awaited<ReturnType<typeof getOrganizationMemberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMemberById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetOrganizationMemberById<
	TData = Awaited<ReturnType<typeof getOrganizationMemberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getOrganizationMemberById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetOrganizationMemberByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * update a organization member
 */
export const updateOrganizationMemberById = (
	id: string,
	updateOrganizationMemberSchema: UpdateOrganizationMemberSchema,
	signal?: AbortSignal
) => {
	return customInstance<UpdateOrganizationMemberById200>({
		url: `/organization/members/${id}`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: updateOrganizationMemberSchema,
		signal
	})
}

export const getUpdateOrganizationMemberByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateOrganizationMemberById>>,
		TError,
		{ id: string; data: UpdateOrganizationMemberSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateOrganizationMemberById>>,
	TError,
	{ id: string; data: UpdateOrganizationMemberSchema },
	TContext
> => {
	const mutationKey = ['updateOrganizationMemberById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateOrganizationMemberById>>,
		{ id: string; data: UpdateOrganizationMemberSchema }
	> = props => {
		const { id, data } = props ?? {}

		return updateOrganizationMemberById(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateOrganizationMemberByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateOrganizationMemberById>>
>
export type UpdateOrganizationMemberByIdMutationBody = UpdateOrganizationMemberSchema
export type UpdateOrganizationMemberByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateOrganizationMemberById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateOrganizationMemberById>>,
		TError,
		{ id: string; data: UpdateOrganizationMemberSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateOrganizationMemberById>>,
	TError,
	{ id: string; data: UpdateOrganizationMemberSchema },
	TContext
> => {
	const mutationOptions = getUpdateOrganizationMemberByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * delete an organization member
 */
export const deleteOrganizationMemberById = (id: string) => {
	return customInstance<DeleteOrganizationMemberByIdResponseSchema>({
		url: `/organization/members/${id}`,
		method: 'DELETE'
	})
}

export const getDeleteOrganizationMemberByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteOrganizationMemberById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteOrganizationMemberById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['deleteOrganizationMemberById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteOrganizationMemberById>>,
		{ id: string }
	> = props => {
		const { id } = props ?? {}

		return deleteOrganizationMemberById(id)
	}

	return { mutationFn, ...mutationOptions }
}

export type DeleteOrganizationMemberByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteOrganizationMemberById>>
>

export type DeleteOrganizationMemberByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useDeleteOrganizationMemberById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteOrganizationMemberById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteOrganizationMemberById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getDeleteOrganizationMemberByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * update a organization member role
 */
export const updateOrganizationMemberRoleById = (
	id: string,
	updateOrganizationMemberRoleSchema: UpdateOrganizationMemberRoleSchema,
	signal?: AbortSignal
) => {
	return customInstance<UpdateOrganizationMemberRoleByIdResponseSchema>({
		url: `/organization/members/${id}/role`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: updateOrganizationMemberRoleSchema,
		signal
	})
}

export const getUpdateOrganizationMemberRoleByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateOrganizationMemberRoleById>>,
		TError,
		{ id: string; data: UpdateOrganizationMemberRoleSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateOrganizationMemberRoleById>>,
	TError,
	{ id: string; data: UpdateOrganizationMemberRoleSchema },
	TContext
> => {
	const mutationKey = ['updateOrganizationMemberRoleById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateOrganizationMemberRoleById>>,
		{ id: string; data: UpdateOrganizationMemberRoleSchema }
	> = props => {
		const { id, data } = props ?? {}

		return updateOrganizationMemberRoleById(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateOrganizationMemberRoleByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateOrganizationMemberRoleById>>
>
export type UpdateOrganizationMemberRoleByIdMutationBody = UpdateOrganizationMemberRoleSchema
export type UpdateOrganizationMemberRoleByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateOrganizationMemberRoleById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateOrganizationMemberRoleById>>,
		TError,
		{ id: string; data: UpdateOrganizationMemberRoleSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateOrganizationMemberRoleById>>,
	TError,
	{ id: string; data: UpdateOrganizationMemberRoleSchema },
	TContext
> => {
	const mutationOptions = getUpdateOrganizationMemberRoleByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * transfer organization ownership
 */
export const transferOrganizationOwnership = (
	id: string,
	transferOrganizationOwnershipSchema: TransferOrganizationOwnershipSchema,
	signal?: AbortSignal
) => {
	return customInstance<TransferOrganizationOwnershipResponseSchema>({
		url: `/organization/${id}/transfer`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: transferOrganizationOwnershipSchema,
		signal
	})
}

export const getTransferOrganizationOwnershipMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof transferOrganizationOwnership>>,
		TError,
		{ id: string; data: TransferOrganizationOwnershipSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof transferOrganizationOwnership>>,
	TError,
	{ id: string; data: TransferOrganizationOwnershipSchema },
	TContext
> => {
	const mutationKey = ['transferOrganizationOwnership']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof transferOrganizationOwnership>>,
		{ id: string; data: TransferOrganizationOwnershipSchema }
	> = props => {
		const { id, data } = props ?? {}

		return transferOrganizationOwnership(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type TransferOrganizationOwnershipMutationResult = NonNullable<
	Awaited<ReturnType<typeof transferOrganizationOwnership>>
>
export type TransferOrganizationOwnershipMutationBody = TransferOrganizationOwnershipSchema
export type TransferOrganizationOwnershipMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useTransferOrganizationOwnership = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof transferOrganizationOwnership>>,
		TError,
		{ id: string; data: TransferOrganizationOwnershipSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof transferOrganizationOwnership>>,
	TError,
	{ id: string; data: TransferOrganizationOwnershipSchema },
	TContext
> => {
	const mutationOptions = getTransferOrganizationOwnershipMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all templates
 */
export const getAllTemplates = (signal?: AbortSignal) => {
	return customInstance<GetAllMessageTemplatesResponseSchema>({
		url: `/organization/templates`,
		method: 'GET',
		signal
	})
}

export const getGetAllTemplatesQueryKey = () => {
	return [`/organization/templates`] as const
}

export const getGetAllTemplatesQueryOptions = <
	TData = Awaited<ReturnType<typeof getAllTemplates>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTemplates>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetAllTemplatesQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTemplates>>> = ({ signal }) =>
		getAllTemplates(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAllTemplates>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAllTemplatesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllTemplates>>>
export type GetAllTemplatesQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetAllTemplates<
	TData = Awaited<ReturnType<typeof getAllTemplates>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options: {
	query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTemplates>>, TError, TData>> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof getAllTemplates>>,
				TError,
				Awaited<ReturnType<typeof getAllTemplates>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllTemplates<
	TData = Awaited<ReturnType<typeof getAllTemplates>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTemplates>>, TError, TData>> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof getAllTemplates>>,
				TError,
				Awaited<ReturnType<typeof getAllTemplates>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllTemplates<
	TData = Awaited<ReturnType<typeof getAllTemplates>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTemplates>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAllTemplates<
	TData = Awaited<ReturnType<typeof getAllTemplates>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllTemplates>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetAllTemplatesQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns a single template
 */
export const getTemplateById = (id: string, signal?: AbortSignal) => {
	return customInstance<GetTemplateByIdResponseSchema>({
		url: `/organization/templates/${id}`,
		method: 'GET',
		signal
	})
}

export const getGetTemplateByIdQueryKey = (id: string) => {
	return [`/organization/templates/${id}`] as const
}

export const getGetTemplateByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getTemplateById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTemplateById>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetTemplateByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getTemplateById>>> = ({ signal }) =>
		getTemplateById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getTemplateById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTemplateByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTemplateById>>>
export type GetTemplateByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetTemplateById<
	TData = Awaited<ReturnType<typeof getTemplateById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getTemplateById>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getTemplateById>>,
					TError,
					Awaited<ReturnType<typeof getTemplateById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTemplateById<
	TData = Awaited<ReturnType<typeof getTemplateById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getTemplateById>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getTemplateById>>,
					TError,
					Awaited<ReturnType<typeof getTemplateById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTemplateById<
	TData = Awaited<ReturnType<typeof getTemplateById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTemplateById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTemplateById<
	TData = Awaited<ReturnType<typeof getTemplateById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTemplateById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetTemplateByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all phone numbers linked to the whatsapp business account
 */
export const getAllPhoneNumbers = (signal?: AbortSignal) => {
	return customInstance<GetAllPhoneNumbersResponseSchema>({
		url: `/organization/phone-numbers`,
		method: 'GET',
		signal
	})
}

export const getGetAllPhoneNumbersQueryKey = () => {
	return [`/organization/phone-numbers`] as const
}

export const getGetAllPhoneNumbersQueryOptions = <
	TData = Awaited<ReturnType<typeof getAllPhoneNumbers>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhoneNumbers>>, TError, TData>>
}) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetAllPhoneNumbersQueryKey()

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllPhoneNumbers>>> = ({ signal }) =>
		getAllPhoneNumbers(signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAllPhoneNumbers>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAllPhoneNumbersQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAllPhoneNumbers>>
>
export type GetAllPhoneNumbersQueryError = unknown

export function useGetAllPhoneNumbers<
	TData = Awaited<ReturnType<typeof getAllPhoneNumbers>>,
	TError = unknown
>(options: {
	query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhoneNumbers>>, TError, TData>> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof getAllPhoneNumbers>>,
				TError,
				Awaited<ReturnType<typeof getAllPhoneNumbers>>
			>,
			'initialData'
		>
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllPhoneNumbers<
	TData = Awaited<ReturnType<typeof getAllPhoneNumbers>>,
	TError = unknown
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof getAllPhoneNumbers>>, TError, TData>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof getAllPhoneNumbers>>,
				TError,
				Awaited<ReturnType<typeof getAllPhoneNumbers>>
			>,
			'initialData'
		>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAllPhoneNumbers<
	TData = Awaited<ReturnType<typeof getAllPhoneNumbers>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhoneNumbers>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAllPhoneNumbers<
	TData = Awaited<ReturnType<typeof getAllPhoneNumbers>>,
	TError = unknown
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllPhoneNumbers>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetAllPhoneNumbersQueryOptions(options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns a single phone number linked to the whatsapp business account
 */
export const getPhoneNumberById = (id: string, signal?: AbortSignal) => {
	return customInstance<PhoneNumberSchema>({
		url: `/organization/phone-numbers/${id}`,
		method: 'GET',
		signal
	})
}

export const getGetPhoneNumberByIdQueryKey = (id: string) => {
	return [`/organization/phone-numbers/${id}`] as const
}

export const getGetPhoneNumberByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getPhoneNumberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPhoneNumberById>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetPhoneNumberByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getPhoneNumberById>>> = ({ signal }) =>
		getPhoneNumberById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getPhoneNumberById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPhoneNumberByIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getPhoneNumberById>>
>
export type GetPhoneNumberByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetPhoneNumberById<
	TData = Awaited<ReturnType<typeof getPhoneNumberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPhoneNumberById>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getPhoneNumberById>>,
					TError,
					Awaited<ReturnType<typeof getPhoneNumberById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPhoneNumberById<
	TData = Awaited<ReturnType<typeof getPhoneNumberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPhoneNumberById>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getPhoneNumberById>>,
					TError,
					Awaited<ReturnType<typeof getPhoneNumberById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPhoneNumberById<
	TData = Awaited<ReturnType<typeof getPhoneNumberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPhoneNumberById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPhoneNumberById<
	TData = Awaited<ReturnType<typeof getPhoneNumberById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPhoneNumberById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetPhoneNumberByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * updates whatsapp business account details for a organization
 */
export const updateWhatsappBusinessAccountDetails = (
	updateWhatsAppBusinessAccountDetailsSchema: UpdateWhatsAppBusinessAccountDetailsSchema,
	signal?: AbortSignal
) => {
	return customInstance<WhatsAppBusinessAccountDetailsSchema>({
		url: `/organization/whatsappBusinessAccount`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: updateWhatsAppBusinessAccountDetailsSchema,
		signal
	})
}

export const getUpdateWhatsappBusinessAccountDetailsMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateWhatsappBusinessAccountDetails>>,
		TError,
		{ data: UpdateWhatsAppBusinessAccountDetailsSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateWhatsappBusinessAccountDetails>>,
	TError,
	{ data: UpdateWhatsAppBusinessAccountDetailsSchema },
	TContext
> => {
	const mutationKey = ['updateWhatsappBusinessAccountDetails']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateWhatsappBusinessAccountDetails>>,
		{ data: UpdateWhatsAppBusinessAccountDetailsSchema }
	> = props => {
		const { data } = props ?? {}

		return updateWhatsappBusinessAccountDetails(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateWhatsappBusinessAccountDetailsMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateWhatsappBusinessAccountDetails>>
>
export type UpdateWhatsappBusinessAccountDetailsMutationBody =
	UpdateWhatsAppBusinessAccountDetailsSchema
export type UpdateWhatsappBusinessAccountDetailsMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateWhatsappBusinessAccountDetails = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateWhatsappBusinessAccountDetails>>,
		TError,
		{ data: UpdateWhatsAppBusinessAccountDetailsSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateWhatsappBusinessAccountDetails>>,
	TError,
	{ data: UpdateWhatsAppBusinessAccountDetailsSchema },
	TContext
> => {
	const mutationOptions = getUpdateWhatsappBusinessAccountDetailsMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all contacts.
 */
export const getContacts = (params: GetContactsParams, signal?: AbortSignal) => {
	return customInstance<GetContactsResponseSchema>({
		url: `/contacts`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetContactsQueryKey = (params: GetContactsParams) => {
	return [`/contacts`, ...(params ? [params] : [])] as const
}

export const getGetContactsQueryOptions = <
	TData = Awaited<ReturnType<typeof getContacts>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContacts>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetContactsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getContacts>>> = ({ signal }) =>
		getContacts(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getContacts>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetContactsQueryResult = NonNullable<Awaited<ReturnType<typeof getContacts>>>
export type GetContactsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetContacts<
	TData = Awaited<ReturnType<typeof getContacts>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactsParams,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContacts>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getContacts>>,
					TError,
					Awaited<ReturnType<typeof getContacts>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetContacts<
	TData = Awaited<ReturnType<typeof getContacts>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContacts>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getContacts>>,
					TError,
					Awaited<ReturnType<typeof getContacts>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetContacts<
	TData = Awaited<ReturnType<typeof getContacts>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContacts>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetContacts<
	TData = Awaited<ReturnType<typeof getContacts>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContacts>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetContactsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * handles creation of new contacts
 */
export const createContacts = (newContactSchema: NewContactSchema[], signal?: AbortSignal) => {
	return customInstance<CreateNewContactResponseSchema>({
		url: `/contacts`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: newContactSchema,
		signal
	})
}

export const getCreateContactsMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createContacts>>,
		TError,
		{ data: NewContactSchema[] },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof createContacts>>,
	TError,
	{ data: NewContactSchema[] },
	TContext
> => {
	const mutationKey = ['createContacts']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createContacts>>,
		{ data: NewContactSchema[] }
	> = props => {
		const { data } = props ?? {}

		return createContacts(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type CreateContactsMutationResult = NonNullable<Awaited<ReturnType<typeof createContacts>>>
export type CreateContactsMutationBody = NewContactSchema[]
export type CreateContactsMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useCreateContacts = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createContacts>>,
		TError,
		{ data: NewContactSchema[] },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof createContacts>>,
	TError,
	{ data: NewContactSchema[] },
	TContext
> => {
	const mutationOptions = getCreateContactsMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * handles contact deletion
 */
export const deleteContactsByList = (params: DeleteContactsByListParams) => {
	return customInstance<DeleteContactsByList200>({ url: `/contacts`, method: 'DELETE', params })
}

export const getDeleteContactsByListMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteContactsByList>>,
		TError,
		{ params: DeleteContactsByListParams },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteContactsByList>>,
	TError,
	{ params: DeleteContactsByListParams },
	TContext
> => {
	const mutationKey = ['deleteContactsByList']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteContactsByList>>,
		{ params: DeleteContactsByListParams }
	> = props => {
		const { params } = props ?? {}

		return deleteContactsByList(params)
	}

	return { mutationFn, ...mutationOptions }
}

export type DeleteContactsByListMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteContactsByList>>
>

export type DeleteContactsByListMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useDeleteContactsByList = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteContactsByList>>,
		TError,
		{ params: DeleteContactsByListParams },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteContactsByList>>,
	TError,
	{ params: DeleteContactsByListParams },
	TContext
> => {
	const mutationOptions = getDeleteContactsByListMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * handles bulk import of contacts
 */
export const bulkImportContacts = (
	bulkImportContactsBody: BulkImportContactsBodyOne | BulkImportSchema,
	signal?: AbortSignal
) => {
	return customInstance<BulkImportResponseSchema>({
		url: `/contacts/bulk-import`,
		method: 'POST',
		data: bulkImportContactsBody,
		signal
	})
}

export const getBulkImportContactsMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof bulkImportContacts>>,
		TError,
		{ data: BulkImportContactsBodyOne | BulkImportSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof bulkImportContacts>>,
	TError,
	{ data: BulkImportContactsBodyOne | BulkImportSchema },
	TContext
> => {
	const mutationKey = ['bulkImportContacts']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof bulkImportContacts>>,
		{ data: BulkImportContactsBodyOne | BulkImportSchema }
	> = props => {
		const { data } = props ?? {}

		return bulkImportContacts(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type BulkImportContactsMutationResult = NonNullable<
	Awaited<ReturnType<typeof bulkImportContacts>>
>
export type BulkImportContactsMutationBody = BulkImportContactsBodyOne | BulkImportSchema
export type BulkImportContactsMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useBulkImportContacts = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof bulkImportContacts>>,
		TError,
		{ data: BulkImportContactsBodyOne | BulkImportSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof bulkImportContacts>>,
	TError,
	{ data: BulkImportContactsBodyOne | BulkImportSchema },
	TContext
> => {
	const mutationOptions = getBulkImportContactsMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * handles the retrieval of a single contact by id.
 */
export const getContactById = (id: string, signal?: AbortSignal) => {
	return customInstance<GetContactByIdResponseSchema>({
		url: `/contacts/${id}`,
		method: 'GET',
		signal
	})
}

export const getGetContactByIdQueryKey = (id: string) => {
	return [`/contacts/${id}`] as const
}

export const getGetContactByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getContactById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContactById>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetContactByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getContactById>>> = ({ signal }) =>
		getContactById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getContactById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetContactByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getContactById>>>
export type GetContactByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetContactById<
	TData = Awaited<ReturnType<typeof getContactById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContactById>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getContactById>>,
					TError,
					Awaited<ReturnType<typeof getContactById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetContactById<
	TData = Awaited<ReturnType<typeof getContactById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getContactById>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getContactById>>,
					TError,
					Awaited<ReturnType<typeof getContactById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetContactById<
	TData = Awaited<ReturnType<typeof getContactById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContactById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetContactById<
	TData = Awaited<ReturnType<typeof getContactById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContactById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetContactByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * modify contact data
 */
export const updateContactById = (
	id: string,
	updateContactSchema: UpdateContactSchema,
	signal?: AbortSignal
) => {
	return customInstance<UpdateContactByIdResponseSchema>({
		url: `/contacts/${id}`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: updateContactSchema,
		signal
	})
}

export const getUpdateContactByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateContactById>>,
		TError,
		{ id: string; data: UpdateContactSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateContactById>>,
	TError,
	{ id: string; data: UpdateContactSchema },
	TContext
> => {
	const mutationKey = ['updateContactById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateContactById>>,
		{ id: string; data: UpdateContactSchema }
	> = props => {
		const { id, data } = props ?? {}

		return updateContactById(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateContactByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateContactById>>
>
export type UpdateContactByIdMutationBody = UpdateContactSchema
export type UpdateContactByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateContactById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateContactById>>,
		TError,
		{ id: string; data: UpdateContactSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateContactById>>,
	TError,
	{ id: string; data: UpdateContactSchema },
	TContext
> => {
	const mutationOptions = getUpdateContactByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * handles contact deletion based on id
 */
export const deleteContactById = (id: string) => {
	return customInstance<DeleteContactByIdResponseSchema>({
		url: `/contacts/${id}`,
		method: 'DELETE'
	})
}

export const getDeleteContactByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteContactById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteContactById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['deleteContactById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteContactById>>,
		{ id: string }
	> = props => {
		const { id } = props ?? {}

		return deleteContactById(id)
	}

	return { mutationFn, ...mutationOptions }
}

export type DeleteContactByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteContactById>>
>

export type DeleteContactByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useDeleteContactById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteContactById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteContactById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getDeleteContactByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all lists.
 */
export const getContactLists = (params: GetContactListsParams, signal?: AbortSignal) => {
	return customInstance<GetContactListResponseSchema>({
		url: `/lists`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetContactListsQueryKey = (params: GetContactListsParams) => {
	return [`/lists`, ...(params ? [params] : [])] as const
}

export const getGetContactListsQueryOptions = <
	TData = Awaited<ReturnType<typeof getContactLists>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactListsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContactLists>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetContactListsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getContactLists>>> = ({ signal }) =>
		getContactLists(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getContactLists>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetContactListsQueryResult = NonNullable<Awaited<ReturnType<typeof getContactLists>>>
export type GetContactListsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetContactLists<
	TData = Awaited<ReturnType<typeof getContactLists>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactListsParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getContactLists>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getContactLists>>,
					TError,
					Awaited<ReturnType<typeof getContactLists>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetContactLists<
	TData = Awaited<ReturnType<typeof getContactLists>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactListsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getContactLists>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getContactLists>>,
					TError,
					Awaited<ReturnType<typeof getContactLists>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetContactLists<
	TData = Awaited<ReturnType<typeof getContactLists>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactListsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContactLists>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetContactLists<
	TData = Awaited<ReturnType<typeof getContactLists>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetContactListsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getContactLists>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetContactListsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * handles creation of new list
 */
export const createList = (newContactListSchema: NewContactListSchema, signal?: AbortSignal) => {
	return customInstance<CreateNewListResponseSchema>({
		url: `/lists`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: newContactListSchema,
		signal
	})
}

export const getCreateListMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createList>>,
		TError,
		{ data: NewContactListSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof createList>>,
	TError,
	{ data: NewContactListSchema },
	TContext
> => {
	const mutationKey = ['createList']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createList>>,
		{ data: NewContactListSchema }
	> = props => {
		const { data } = props ?? {}

		return createList(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type CreateListMutationResult = NonNullable<Awaited<ReturnType<typeof createList>>>
export type CreateListMutationBody = NewContactListSchema
export type CreateListMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useCreateList = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createList>>,
		TError,
		{ data: NewContactListSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof createList>>,
	TError,
	{ data: NewContactListSchema },
	TContext
> => {
	const mutationOptions = getCreateListMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * handles the retrieval of a single list by id.
 */
export const getListById = (id: string, signal?: AbortSignal) => {
	return customInstance<GetContactListByIdSchema>({ url: `/lists/${id}`, method: 'GET', signal })
}

export const getGetListByIdQueryKey = (id: string) => {
	return [`/lists/${id}`] as const
}

export const getGetListByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getListById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getListById>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetListByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getListById>>> = ({ signal }) =>
		getListById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getListById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetListByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getListById>>>
export type GetListByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetListById<
	TData = Awaited<ReturnType<typeof getListById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getListById>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getListById>>,
					TError,
					Awaited<ReturnType<typeof getListById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetListById<
	TData = Awaited<ReturnType<typeof getListById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getListById>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getListById>>,
					TError,
					Awaited<ReturnType<typeof getListById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetListById<
	TData = Awaited<ReturnType<typeof getListById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getListById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetListById<
	TData = Awaited<ReturnType<typeof getListById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getListById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetListByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * modify list data
 */
export const updateListById = (
	id: string,
	updateContactListSchema: UpdateContactListSchema,
	signal?: AbortSignal
) => {
	return customInstance<UpdateListByIdResponseSchema>({
		url: `/lists/${id}`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: updateContactListSchema,
		signal
	})
}

export const getUpdateListByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateListById>>,
		TError,
		{ id: string; data: UpdateContactListSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateListById>>,
	TError,
	{ id: string; data: UpdateContactListSchema },
	TContext
> => {
	const mutationKey = ['updateListById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateListById>>,
		{ id: string; data: UpdateContactListSchema }
	> = props => {
		const { id, data } = props ?? {}

		return updateListById(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateListByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateListById>>>
export type UpdateListByIdMutationBody = UpdateContactListSchema
export type UpdateListByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateListById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateListById>>,
		TError,
		{ id: string; data: UpdateContactListSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateListById>>,
	TError,
	{ id: string; data: UpdateContactListSchema },
	TContext
> => {
	const mutationOptions = getUpdateListByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * handles list deletion based on id
 */
export const deleteListById = (id: string) => {
	return customInstance<DeleteListById200>({ url: `/lists/${id}`, method: 'DELETE' })
}

export const getDeleteListByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteListById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteListById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['deleteListById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteListById>>,
		{ id: string }
	> = props => {
		const { id } = props ?? {}

		return deleteListById(id)
	}

	return { mutationFn, ...mutationOptions }
}

export type DeleteListByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteListById>>>

export type DeleteListByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useDeleteListById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteListById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteListById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getDeleteListByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all campaigns.
 */
export const getCampaigns = (params: GetCampaignsParams, signal?: AbortSignal) => {
	return customInstance<GetCampaignResponseSchema>({
		url: `/campaigns`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetCampaignsQueryKey = (params: GetCampaignsParams) => {
	return [`/campaigns`, ...(params ? [params] : [])] as const
}

export const getGetCampaignsQueryOptions = <
	TData = Awaited<ReturnType<typeof getCampaigns>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetCampaignsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampaigns>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetCampaignsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampaigns>>> = ({ signal }) =>
		getCampaigns(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCampaigns>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCampaignsQueryResult = NonNullable<Awaited<ReturnType<typeof getCampaigns>>>
export type GetCampaignsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetCampaigns<
	TData = Awaited<ReturnType<typeof getCampaigns>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetCampaignsParams,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampaigns>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getCampaigns>>,
					TError,
					Awaited<ReturnType<typeof getCampaigns>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCampaigns<
	TData = Awaited<ReturnType<typeof getCampaigns>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetCampaignsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampaigns>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getCampaigns>>,
					TError,
					Awaited<ReturnType<typeof getCampaigns>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCampaigns<
	TData = Awaited<ReturnType<typeof getCampaigns>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetCampaignsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampaigns>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCampaigns<
	TData = Awaited<ReturnType<typeof getCampaigns>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetCampaignsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampaigns>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetCampaignsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * handles creation of new campaign
 */
export const createCampaign = (newCampaignSchema: NewCampaignSchema, signal?: AbortSignal) => {
	return customInstance<CreateNewCampaignResponseSchema>({
		url: `/campaigns`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: newCampaignSchema,
		signal
	})
}

export const getCreateCampaignMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createCampaign>>,
		TError,
		{ data: NewCampaignSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof createCampaign>>,
	TError,
	{ data: NewCampaignSchema },
	TContext
> => {
	const mutationKey = ['createCampaign']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createCampaign>>,
		{ data: NewCampaignSchema }
	> = props => {
		const { data } = props ?? {}

		return createCampaign(data)
	}

	return { mutationFn, ...mutationOptions }
}

export type CreateCampaignMutationResult = NonNullable<Awaited<ReturnType<typeof createCampaign>>>
export type CreateCampaignMutationBody = NewCampaignSchema
export type CreateCampaignMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useCreateCampaign = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createCampaign>>,
		TError,
		{ data: NewCampaignSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof createCampaign>>,
	TError,
	{ data: NewCampaignSchema },
	TContext
> => {
	const mutationOptions = getCreateCampaignMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * handles the retrieval of a single campaign by id.
 */
export const getCampaignById = (id: string, signal?: AbortSignal) => {
	return customInstance<GetCampaignByIdResponseSchema>({
		url: `/campaigns/${id}`,
		method: 'GET',
		signal
	})
}

export const getGetCampaignByIdQueryKey = (id: string) => {
	return [`/campaigns/${id}`] as const
}

export const getGetCampaignByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getCampaignById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampaignById>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetCampaignByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampaignById>>> = ({ signal }) =>
		getCampaignById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCampaignById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCampaignByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCampaignById>>>
export type GetCampaignByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetCampaignById<
	TData = Awaited<ReturnType<typeof getCampaignById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignById>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getCampaignById>>,
					TError,
					Awaited<ReturnType<typeof getCampaignById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCampaignById<
	TData = Awaited<ReturnType<typeof getCampaignById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignById>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getCampaignById>>,
					TError,
					Awaited<ReturnType<typeof getCampaignById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCampaignById<
	TData = Awaited<ReturnType<typeof getCampaignById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampaignById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCampaignById<
	TData = Awaited<ReturnType<typeof getCampaignById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getCampaignById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetCampaignByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * modify campaign data
 */
export const updateCampaignById = (
	id: string,
	updateCampaignSchema: UpdateCampaignSchema,
	signal?: AbortSignal
) => {
	return customInstance<UpdateCampaignByIdResponseSchema>({
		url: `/campaigns/${id}`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: updateCampaignSchema,
		signal
	})
}

export const getUpdateCampaignByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateCampaignById>>,
		TError,
		{ id: string; data: UpdateCampaignSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateCampaignById>>,
	TError,
	{ id: string; data: UpdateCampaignSchema },
	TContext
> => {
	const mutationKey = ['updateCampaignById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateCampaignById>>,
		{ id: string; data: UpdateCampaignSchema }
	> = props => {
		const { id, data } = props ?? {}

		return updateCampaignById(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateCampaignByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateCampaignById>>
>
export type UpdateCampaignByIdMutationBody = UpdateCampaignSchema
export type UpdateCampaignByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateCampaignById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateCampaignById>>,
		TError,
		{ id: string; data: UpdateCampaignSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateCampaignById>>,
	TError,
	{ id: string; data: UpdateCampaignSchema },
	TContext
> => {
	const mutationOptions = getUpdateCampaignByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * handles campaign deletion based on id
 */
export const deleteCampaignById = (id: string) => {
	return customInstance<DeleteCampaignById200>({ url: `/campaigns/${id}`, method: 'DELETE' })
}

export const getDeleteCampaignByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteCampaignById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteCampaignById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['deleteCampaignById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteCampaignById>>,
		{ id: string }
	> = props => {
		const { id } = props ?? {}

		return deleteCampaignById(id)
	}

	return { mutationFn, ...mutationOptions }
}

export type DeleteCampaignByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteCampaignById>>
>

export type DeleteCampaignByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useDeleteCampaignById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteCampaignById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteCampaignById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getDeleteCampaignByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns paginated conversations.
 */
export const getConversations = (params: GetConversationsParams, signal?: AbortSignal) => {
	return customInstance<GetConversationsResponseSchema>({
		url: `/conversations`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetConversationsQueryKey = (params: GetConversationsParams) => {
	return [`/conversations`, ...(params ? [params] : [])] as const
}

export const getGetConversationsQueryOptions = <
	TData = Awaited<ReturnType<typeof getConversations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversations>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetConversationsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getConversations>>> = ({ signal }) =>
		getConversations(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getConversations>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetConversationsQueryResult = NonNullable<Awaited<ReturnType<typeof getConversations>>>
export type GetConversationsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetConversations<
	TData = Awaited<ReturnType<typeof getConversations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationsParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversations>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getConversations>>,
					TError,
					Awaited<ReturnType<typeof getConversations>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversations<
	TData = Awaited<ReturnType<typeof getConversations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversations>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getConversations>>,
					TError,
					Awaited<ReturnType<typeof getConversations>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversations<
	TData = Awaited<ReturnType<typeof getConversations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversations>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetConversations<
	TData = Awaited<ReturnType<typeof getConversations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversations>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetConversationsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns a single conversation
 */
export const getConversationById = (id: string, signal?: AbortSignal) => {
	return customInstance<GetConversationByIdResponseSchema>({
		url: `/conversation/${id}`,
		method: 'GET',
		signal
	})
}

export const getGetConversationByIdQueryKey = (id: string) => {
	return [`/conversation/${id}`] as const
}

export const getGetConversationByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getConversationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationById>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetConversationByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getConversationById>>> = ({ signal }) =>
		getConversationById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getConversationById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetConversationByIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getConversationById>>
>
export type GetConversationByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetConversationById<
	TData = Awaited<ReturnType<typeof getConversationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationById>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getConversationById>>,
					TError,
					Awaited<ReturnType<typeof getConversationById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationById<
	TData = Awaited<ReturnType<typeof getConversationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationById>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getConversationById>>,
					TError,
					Awaited<ReturnType<typeof getConversationById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationById<
	TData = Awaited<ReturnType<typeof getConversationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetConversationById<
	TData = Awaited<ReturnType<typeof getConversationById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetConversationByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * update a conversation
 */
export const updateConversationById = (
	id: string,
	updateConversationSchema: UpdateConversationSchema,
	signal?: AbortSignal
) => {
	return customInstance<UpdateConversationByIdResponseSchema>({
		url: `/conversation/${id}`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: updateConversationSchema,
		signal
	})
}

export const getUpdateConversationByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateConversationById>>,
		TError,
		{ id: string; data: UpdateConversationSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateConversationById>>,
	TError,
	{ id: string; data: UpdateConversationSchema },
	TContext
> => {
	const mutationKey = ['updateConversationById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateConversationById>>,
		{ id: string; data: UpdateConversationSchema }
	> = props => {
		const { id, data } = props ?? {}

		return updateConversationById(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UpdateConversationByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateConversationById>>
>
export type UpdateConversationByIdMutationBody = UpdateConversationSchema
export type UpdateConversationByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUpdateConversationById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateConversationById>>,
		TError,
		{ id: string; data: UpdateConversationSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof updateConversationById>>,
	TError,
	{ id: string; data: UpdateConversationSchema },
	TContext
> => {
	const mutationOptions = getUpdateConversationByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * delete a conversation
 */
export const deleteConversationById = (id: string) => {
	return customInstance<DeleteConversationByIdResponseSchema>({
		url: `/conversation/${id}`,
		method: 'DELETE'
	})
}

export const getDeleteConversationByIdMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteConversationById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteConversationById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['deleteConversationById']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteConversationById>>,
		{ id: string }
	> = props => {
		const { id } = props ?? {}

		return deleteConversationById(id)
	}

	return { mutationFn, ...mutationOptions }
}

export type DeleteConversationByIdMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteConversationById>>
>

export type DeleteConversationByIdMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useDeleteConversationById = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteConversationById>>,
		TError,
		{ id: string },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteConversationById>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getDeleteConversationByIdMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * assign a conversation to a user
 */
export const assignConversation = (
	id: string,
	assignConversationSchema: AssignConversationSchema,
	signal?: AbortSignal
) => {
	return customInstance<AssignConversationResponseSchema>({
		url: `/conversation/${id}/assign`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: assignConversationSchema,
		signal
	})
}

export const getAssignConversationMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof assignConversation>>,
		TError,
		{ id: string; data: AssignConversationSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof assignConversation>>,
	TError,
	{ id: string; data: AssignConversationSchema },
	TContext
> => {
	const mutationKey = ['assignConversation']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof assignConversation>>,
		{ id: string; data: AssignConversationSchema }
	> = props => {
		const { id, data } = props ?? {}

		return assignConversation(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type AssignConversationMutationResult = NonNullable<
	Awaited<ReturnType<typeof assignConversation>>
>
export type AssignConversationMutationBody = AssignConversationSchema
export type AssignConversationMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useAssignConversation = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof assignConversation>>,
		TError,
		{ id: string; data: AssignConversationSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof assignConversation>>,
	TError,
	{ id: string; data: AssignConversationSchema },
	TContext
> => {
	const mutationOptions = getAssignConversationMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * unassign a conversation from a user
 */
export const unassignConversation = (
	id: string,
	unassignConversationSchema: UnassignConversationSchema,
	signal?: AbortSignal
) => {
	return customInstance<UnassignConversationResponseSchema>({
		url: `/conversation/${id}/unassign`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: unassignConversationSchema,
		signal
	})
}

export const getUnassignConversationMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof unassignConversation>>,
		TError,
		{ id: string; data: UnassignConversationSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof unassignConversation>>,
	TError,
	{ id: string; data: UnassignConversationSchema },
	TContext
> => {
	const mutationKey = ['unassignConversation']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof unassignConversation>>,
		{ id: string; data: UnassignConversationSchema }
	> = props => {
		const { id, data } = props ?? {}

		return unassignConversation(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type UnassignConversationMutationResult = NonNullable<
	Awaited<ReturnType<typeof unassignConversation>>
>
export type UnassignConversationMutationBody = UnassignConversationSchema
export type UnassignConversationMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useUnassignConversation = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof unassignConversation>>,
		TError,
		{ id: string; data: UnassignConversationSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof unassignConversation>>,
	TError,
	{ id: string; data: UnassignConversationSchema },
	TContext
> => {
	const mutationOptions = getUnassignConversationMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all messages in a conversation.
 */
export const getConversationMessages = (
	id: string,
	params: GetConversationMessagesParams,
	signal?: AbortSignal
) => {
	return customInstance<GetConversationMessagesResponseSchema>({
		url: `/conversation/${id}/messages`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetConversationMessagesQueryKey = (
	id: string,
	params: GetConversationMessagesParams
) => {
	return [`/conversation/${id}/messages`, ...(params ? [params] : [])] as const
}

export const getGetConversationMessagesQueryOptions = <
	TData = Awaited<ReturnType<typeof getConversationMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetConversationMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationMessages>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetConversationMessagesQueryKey(id, params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getConversationMessages>>> = ({
		signal
	}) => getConversationMessages(id, params, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getConversationMessages>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetConversationMessagesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getConversationMessages>>
>
export type GetConversationMessagesQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetConversationMessages<
	TData = Awaited<ReturnType<typeof getConversationMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetConversationMessagesParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationMessages>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getConversationMessages>>,
					TError,
					Awaited<ReturnType<typeof getConversationMessages>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationMessages<
	TData = Awaited<ReturnType<typeof getConversationMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetConversationMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationMessages>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getConversationMessages>>,
					TError,
					Awaited<ReturnType<typeof getConversationMessages>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationMessages<
	TData = Awaited<ReturnType<typeof getConversationMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetConversationMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationMessages>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetConversationMessages<
	TData = Awaited<ReturnType<typeof getConversationMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetConversationMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getConversationMessages>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetConversationMessagesQueryOptions(id, params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * send a message in a conversation
 */
export const sendMessageInConversation = (
	id: string,
	newMessageSchema: NewMessageSchema,
	signal?: AbortSignal
) => {
	return customInstance<SendMessageInConversationResponseSchema>({
		url: `/conversation/${id}/messages`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: newMessageSchema,
		signal
	})
}

export const getSendMessageInConversationMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sendMessageInConversation>>,
		TError,
		{ id: string; data: NewMessageSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof sendMessageInConversation>>,
	TError,
	{ id: string; data: NewMessageSchema },
	TContext
> => {
	const mutationKey = ['sendMessageInConversation']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sendMessageInConversation>>,
		{ id: string; data: NewMessageSchema }
	> = props => {
		const { id, data } = props ?? {}

		return sendMessageInConversation(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type SendMessageInConversationMutationResult = NonNullable<
	Awaited<ReturnType<typeof sendMessageInConversation>>
>
export type SendMessageInConversationMutationBody = NewMessageSchema
export type SendMessageInConversationMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useSendMessageInConversation = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sendMessageInConversation>>,
		TError,
		{ id: string; data: NewMessageSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof sendMessageInConversation>>,
	TError,
	{ id: string; data: NewMessageSchema },
	TContext
> => {
	const mutationOptions = getSendMessageInConversationMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all messages.
 */
export const getMessages = (params?: GetMessagesParams, signal?: AbortSignal) => {
	return customInstance<GetMessages200>({ url: `/messages`, method: 'GET', params, signal })
}

export const getGetMessagesQueryKey = (params?: GetMessagesParams) => {
	return [`/messages`, ...(params ? [params] : [])] as const
}

export const getGetMessagesQueryOptions = <
	TData = Awaited<ReturnType<typeof getMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetMessagesParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetMessagesQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessages>>> = ({ signal }) =>
		getMessages(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getMessages>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMessagesQueryResult = NonNullable<Awaited<ReturnType<typeof getMessages>>>
export type GetMessagesQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetMessages<
	TData = Awaited<ReturnType<typeof getMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: undefined | GetMessagesParams,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getMessages>>,
					TError,
					Awaited<ReturnType<typeof getMessages>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMessages<
	TData = Awaited<ReturnType<typeof getMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetMessagesParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getMessages>>,
					TError,
					Awaited<ReturnType<typeof getMessages>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMessages<
	TData = Awaited<ReturnType<typeof getMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetMessagesParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMessages<
	TData = Awaited<ReturnType<typeof getMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetMessagesParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessages>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetMessagesQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all integrations.
 */
export const getIntegrations = (params?: GetIntegrationsParams, signal?: AbortSignal) => {
	return customInstance<GetIntegrationResponseSchema>({
		url: `/integrations`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetIntegrationsQueryKey = (params?: GetIntegrationsParams) => {
	return [`/integrations`, ...(params ? [params] : [])] as const
}

export const getGetIntegrationsQueryOptions = <
	TData = Awaited<ReturnType<typeof getIntegrations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetIntegrationsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrations>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetIntegrationsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getIntegrations>>> = ({ signal }) =>
		getIntegrations(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getIntegrations>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetIntegrationsQueryResult = NonNullable<Awaited<ReturnType<typeof getIntegrations>>>
export type GetIntegrationsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetIntegrations<
	TData = Awaited<ReturnType<typeof getIntegrations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: undefined | GetIntegrationsParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getIntegrations>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getIntegrations>>,
					TError,
					Awaited<ReturnType<typeof getIntegrations>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIntegrations<
	TData = Awaited<ReturnType<typeof getIntegrations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetIntegrationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getIntegrations>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getIntegrations>>,
					TError,
					Awaited<ReturnType<typeof getIntegrations>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetIntegrations<
	TData = Awaited<ReturnType<typeof getIntegrations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetIntegrationsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrations>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetIntegrations<
	TData = Awaited<ReturnType<typeof getIntegrations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetIntegrationsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getIntegrations>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetIntegrationsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns main analytics dashboard data.
 */
export const getPrimaryAnalytics = (params: GetPrimaryAnalyticsParams, signal?: AbortSignal) => {
	return customInstance<PrimaryAnalyticsResponseSchema>({
		url: `/analytics/primary`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetPrimaryAnalyticsQueryKey = (params: GetPrimaryAnalyticsParams) => {
	return [`/analytics/primary`, ...(params ? [params] : [])] as const
}

export const getGetPrimaryAnalyticsQueryOptions = <
	TData = Awaited<ReturnType<typeof getPrimaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetPrimaryAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPrimaryAnalytics>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetPrimaryAnalyticsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getPrimaryAnalytics>>> = ({ signal }) =>
		getPrimaryAnalytics(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getPrimaryAnalytics>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetPrimaryAnalyticsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getPrimaryAnalytics>>
>
export type GetPrimaryAnalyticsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetPrimaryAnalytics<
	TData = Awaited<ReturnType<typeof getPrimaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetPrimaryAnalyticsParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPrimaryAnalytics>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getPrimaryAnalytics>>,
					TError,
					Awaited<ReturnType<typeof getPrimaryAnalytics>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPrimaryAnalytics<
	TData = Awaited<ReturnType<typeof getPrimaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetPrimaryAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPrimaryAnalytics>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getPrimaryAnalytics>>,
					TError,
					Awaited<ReturnType<typeof getPrimaryAnalytics>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetPrimaryAnalytics<
	TData = Awaited<ReturnType<typeof getPrimaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetPrimaryAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPrimaryAnalytics>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetPrimaryAnalytics<
	TData = Awaited<ReturnType<typeof getPrimaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetPrimaryAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getPrimaryAnalytics>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetPrimaryAnalyticsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all secondary analytics.
 */
export const getSecondaryAnalytics = (
	params?: GetSecondaryAnalyticsParams,
	signal?: AbortSignal
) => {
	return customInstance<SecondaryAnalyticsDashboardResponseSchema>({
		url: `/analytics/secondary`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetSecondaryAnalyticsQueryKey = (params?: GetSecondaryAnalyticsParams) => {
	return [`/analytics/secondary`, ...(params ? [params] : [])] as const
}

export const getGetSecondaryAnalyticsQueryOptions = <
	TData = Awaited<ReturnType<typeof getSecondaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetSecondaryAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSecondaryAnalytics>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetSecondaryAnalyticsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getSecondaryAnalytics>>> = ({
		signal
	}) => getSecondaryAnalytics(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getSecondaryAnalytics>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSecondaryAnalyticsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getSecondaryAnalytics>>
>
export type GetSecondaryAnalyticsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetSecondaryAnalytics<
	TData = Awaited<ReturnType<typeof getSecondaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: undefined | GetSecondaryAnalyticsParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSecondaryAnalytics>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSecondaryAnalytics>>,
					TError,
					Awaited<ReturnType<typeof getSecondaryAnalytics>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSecondaryAnalytics<
	TData = Awaited<ReturnType<typeof getSecondaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetSecondaryAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSecondaryAnalytics>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getSecondaryAnalytics>>,
					TError,
					Awaited<ReturnType<typeof getSecondaryAnalytics>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSecondaryAnalytics<
	TData = Awaited<ReturnType<typeof getSecondaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetSecondaryAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSecondaryAnalytics>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSecondaryAnalytics<
	TData = Awaited<ReturnType<typeof getSecondaryAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetSecondaryAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getSecondaryAnalytics>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetSecondaryAnalyticsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns campaign analytics.
 */
export const getCampaignAnalyticsById = (campaignId: string, signal?: AbortSignal) => {
	return customInstance<CampaignAnalyticsResponseSchema>({
		url: `/analytics/campaign/${campaignId}`,
		method: 'GET',
		signal
	})
}

export const getGetCampaignAnalyticsByIdQueryKey = (campaignId: string) => {
	return [`/analytics/campaign/${campaignId}`] as const
}

export const getGetCampaignAnalyticsByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getCampaignAnalyticsById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	campaignId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignAnalyticsById>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetCampaignAnalyticsByIdQueryKey(campaignId)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampaignAnalyticsById>>> = ({
		signal
	}) => getCampaignAnalyticsById(campaignId, signal)

	return { queryKey, queryFn, enabled: !!campaignId, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCampaignAnalyticsById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCampaignAnalyticsByIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCampaignAnalyticsById>>
>
export type GetCampaignAnalyticsByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetCampaignAnalyticsById<
	TData = Awaited<ReturnType<typeof getCampaignAnalyticsById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	campaignId: string,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignAnalyticsById>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getCampaignAnalyticsById>>,
					TError,
					Awaited<ReturnType<typeof getCampaignAnalyticsById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCampaignAnalyticsById<
	TData = Awaited<ReturnType<typeof getCampaignAnalyticsById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	campaignId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignAnalyticsById>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getCampaignAnalyticsById>>,
					TError,
					Awaited<ReturnType<typeof getCampaignAnalyticsById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCampaignAnalyticsById<
	TData = Awaited<ReturnType<typeof getCampaignAnalyticsById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	campaignId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignAnalyticsById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCampaignAnalyticsById<
	TData = Awaited<ReturnType<typeof getCampaignAnalyticsById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	campaignId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignAnalyticsById>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetCampaignAnalyticsByIdQueryOptions(campaignId, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all campaigns analytics.
 */
export const getCampaignsAnalytics = (
	params?: GetCampaignsAnalyticsParams,
	signal?: AbortSignal
) => {
	return customInstance<CampaignAnalyticsResponseSchema>({
		url: `/analytics/campaigns`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetCampaignsAnalyticsQueryKey = (params?: GetCampaignsAnalyticsParams) => {
	return [`/analytics/campaigns`, ...(params ? [params] : [])] as const
}

export const getGetCampaignsAnalyticsQueryOptions = <
	TData = Awaited<ReturnType<typeof getCampaignsAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetCampaignsAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignsAnalytics>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetCampaignsAnalyticsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getCampaignsAnalytics>>> = ({
		signal
	}) => getCampaignsAnalytics(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getCampaignsAnalytics>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCampaignsAnalyticsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getCampaignsAnalytics>>
>
export type GetCampaignsAnalyticsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetCampaignsAnalytics<
	TData = Awaited<ReturnType<typeof getCampaignsAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: undefined | GetCampaignsAnalyticsParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignsAnalytics>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getCampaignsAnalytics>>,
					TError,
					Awaited<ReturnType<typeof getCampaignsAnalytics>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCampaignsAnalytics<
	TData = Awaited<ReturnType<typeof getCampaignsAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetCampaignsAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignsAnalytics>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getCampaignsAnalytics>>,
					TError,
					Awaited<ReturnType<typeof getCampaignsAnalytics>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCampaignsAnalytics<
	TData = Awaited<ReturnType<typeof getCampaignsAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetCampaignsAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignsAnalytics>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCampaignsAnalytics<
	TData = Awaited<ReturnType<typeof getCampaignsAnalytics>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetCampaignsAnalyticsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getCampaignsAnalytics>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetCampaignsAnalyticsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all ai chats.
 */
export const getAiChats = (params?: GetAiChatsParams, signal?: AbortSignal) => {
	return customInstance<GetAiChatsResponseSchema>({
		url: `/ai/chats`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetAiChatsQueryKey = (params?: GetAiChatsParams) => {
	return [`/ai/chats`, ...(params ? [params] : [])] as const
}

export const getGetAiChatsQueryOptions = <
	TData = Awaited<ReturnType<typeof getAiChats>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetAiChatsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChats>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetAiChatsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAiChats>>> = ({ signal }) =>
		getAiChats(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAiChats>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAiChatsQueryResult = NonNullable<Awaited<ReturnType<typeof getAiChats>>>
export type GetAiChatsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetAiChats<
	TData = Awaited<ReturnType<typeof getAiChats>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: undefined | GetAiChatsParams,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChats>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChats>>,
					TError,
					Awaited<ReturnType<typeof getAiChats>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChats<
	TData = Awaited<ReturnType<typeof getAiChats>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetAiChatsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChats>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChats>>,
					TError,
					Awaited<ReturnType<typeof getAiChats>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChats<
	TData = Awaited<ReturnType<typeof getAiChats>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetAiChatsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChats>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAiChats<
	TData = Awaited<ReturnType<typeof getAiChats>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetAiChatsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChats>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetAiChatsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns a single ai chat
 */
export const getAiChatById = (id: string, signal?: AbortSignal) => {
	return customInstance<GetAiChatByIdResponseSchema>({
		url: `/ai/chat/${id}`,
		method: 'GET',
		signal
	})
}

export const getGetAiChatByIdQueryKey = (id: string) => {
	return [`/ai/chat/${id}`] as const
}

export const getGetAiChatByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getAiChatById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChatById>>, TError, TData>>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetAiChatByIdQueryKey(id)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAiChatById>>> = ({ signal }) =>
		getAiChatById(id, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAiChatById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAiChatByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAiChatById>>>
export type GetAiChatByIdQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetAiChatById<
	TData = Awaited<ReturnType<typeof getAiChatById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChatById>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChatById>>,
					TError,
					Awaited<ReturnType<typeof getAiChatById>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChatById<
	TData = Awaited<ReturnType<typeof getAiChatById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChatById>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChatById>>,
					TError,
					Awaited<ReturnType<typeof getAiChatById>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChatById<
	TData = Awaited<ReturnType<typeof getAiChatById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChatById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAiChatById<
	TData = Awaited<ReturnType<typeof getAiChatById>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAiChatById>>, TError, TData>>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetAiChatByIdQueryOptions(id, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all messages in a ai chat.
 */
export const getAiChatMessages = (
	id: string,
	params: GetAiChatMessagesParams,
	signal?: AbortSignal
) => {
	return customInstance<GetAiChatMessagesResponseSchema>({
		url: `/ai/chat/${id}/messages`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetAiChatMessagesQueryKey = (id: string, params: GetAiChatMessagesParams) => {
	return [`/ai/chat/${id}/messages`, ...(params ? [params] : [])] as const
}

export const getGetAiChatMessagesQueryOptions = <
	TData = Awaited<ReturnType<typeof getAiChatMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessages>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetAiChatMessagesQueryKey(id, params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAiChatMessages>>> = ({ signal }) =>
		getAiChatMessages(id, params, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAiChatMessages>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAiChatMessagesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAiChatMessages>>
>
export type GetAiChatMessagesQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetAiChatMessages<
	TData = Awaited<ReturnType<typeof getAiChatMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessagesParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessages>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChatMessages>>,
					TError,
					Awaited<ReturnType<typeof getAiChatMessages>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChatMessages<
	TData = Awaited<ReturnType<typeof getAiChatMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessages>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChatMessages>>,
					TError,
					Awaited<ReturnType<typeof getAiChatMessages>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChatMessages<
	TData = Awaited<ReturnType<typeof getAiChatMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessages>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAiChatMessages<
	TData = Awaited<ReturnType<typeof getAiChatMessages>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessages>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetAiChatMessagesQueryOptions(id, params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * send a message in a ai chat
 */
export const sendMessageInAiChat = (
	id: string,
	aiChatQuerySchema: AiChatQuerySchema,
	signal?: AbortSignal
) => {
	return customInstance<Blob>({
		url: `/ai/chat/${id}/messages`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: aiChatQuerySchema,
		responseType: 'blob',
		signal
	})
}

export const getSendMessageInAiChatMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sendMessageInAiChat>>,
		TError,
		{ id: string; data: AiChatQuerySchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof sendMessageInAiChat>>,
	TError,
	{ id: string; data: AiChatQuerySchema },
	TContext
> => {
	const mutationKey = ['sendMessageInAiChat']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sendMessageInAiChat>>,
		{ id: string; data: AiChatQuerySchema }
	> = props => {
		const { id, data } = props ?? {}

		return sendMessageInAiChat(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type SendMessageInAiChatMutationResult = NonNullable<
	Awaited<ReturnType<typeof sendMessageInAiChat>>
>
export type SendMessageInAiChatMutationBody = AiChatQuerySchema
export type SendMessageInAiChatMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useSendMessageInAiChat = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sendMessageInAiChat>>,
		TError,
		{ id: string; data: AiChatQuerySchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof sendMessageInAiChat>>,
	TError,
	{ id: string; data: AiChatQuerySchema },
	TContext
> => {
	const mutationOptions = getSendMessageInAiChatMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all votes on a message in a ai chat.
 */
export const getAiChatMessageVotes = (
	id: string,
	params: GetAiChatMessageVotesParams,
	signal?: AbortSignal
) => {
	return customInstance<GetAiChatVotesResponseSchema>({
		url: `/ai/chat/${id}/vote`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetAiChatMessageVotesQueryKey = (
	id: string,
	params: GetAiChatMessageVotesParams
) => {
	return [`/ai/chat/${id}/vote`, ...(params ? [params] : [])] as const
}

export const getGetAiChatMessageVotesQueryOptions = <
	TData = Awaited<ReturnType<typeof getAiChatMessageVotes>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessageVotesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessageVotes>>, TError, TData>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetAiChatMessageVotesQueryKey(id, params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAiChatMessageVotes>>> = ({
		signal
	}) => getAiChatMessageVotes(id, params, signal)

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAiChatMessageVotes>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAiChatMessageVotesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAiChatMessageVotes>>
>
export type GetAiChatMessageVotesQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetAiChatMessageVotes<
	TData = Awaited<ReturnType<typeof getAiChatMessageVotes>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessageVotesParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessageVotes>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChatMessageVotes>>,
					TError,
					Awaited<ReturnType<typeof getAiChatMessageVotes>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChatMessageVotes<
	TData = Awaited<ReturnType<typeof getAiChatMessageVotes>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessageVotesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessageVotes>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChatMessageVotes>>,
					TError,
					Awaited<ReturnType<typeof getAiChatMessageVotes>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChatMessageVotes<
	TData = Awaited<ReturnType<typeof getAiChatMessageVotes>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessageVotesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessageVotes>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAiChatMessageVotes<
	TData = Awaited<ReturnType<typeof getAiChatMessageVotes>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	id: string,
	params: GetAiChatMessageVotesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAiChatMessageVotes>>, TError, TData>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetAiChatMessageVotesQueryOptions(id, params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * vote on a message in a ai chat
 */
export const voteOnAiChatMessage = (
	id: string,
	aiChatMessageVoteCreateSchema: AiChatMessageVoteCreateSchema,
	signal?: AbortSignal
) => {
	return customInstance<CreateAiChatMessageVoteResponseSchema>({
		url: `/ai/chat/${id}/vote`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: aiChatMessageVoteCreateSchema,
		signal
	})
}

export const getVoteOnAiChatMessageMutationOptions = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof voteOnAiChatMessage>>,
		TError,
		{ id: string; data: AiChatMessageVoteCreateSchema },
		TContext
	>
}): UseMutationOptions<
	Awaited<ReturnType<typeof voteOnAiChatMessage>>,
	TError,
	{ id: string; data: AiChatMessageVoteCreateSchema },
	TContext
> => {
	const mutationKey = ['voteOnAiChatMessage']
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } }

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof voteOnAiChatMessage>>,
		{ id: string; data: AiChatMessageVoteCreateSchema }
	> = props => {
		const { id, data } = props ?? {}

		return voteOnAiChatMessage(id, data)
	}

	return { mutationFn, ...mutationOptions }
}

export type VoteOnAiChatMessageMutationResult = NonNullable<
	Awaited<ReturnType<typeof voteOnAiChatMessage>>
>
export type VoteOnAiChatMessageMutationBody = AiChatMessageVoteCreateSchema
export type VoteOnAiChatMessageMutationError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export const useVoteOnAiChatMessage = <
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof voteOnAiChatMessage>>,
		TError,
		{ id: string; data: AiChatMessageVoteCreateSchema },
		TContext
	>
}): UseMutationResult<
	Awaited<ReturnType<typeof voteOnAiChatMessage>>,
	TError,
	{ id: string; data: AiChatMessageVoteCreateSchema },
	TContext
> => {
	const mutationOptions = getVoteOnAiChatMessageMutationOptions(options)

	return useMutation(mutationOptions)
}

/**
 * returns all ai chat segment recommendations.
 */
export const getAiChatSegmentRecommendations = (
	params?: GetAiChatSegmentRecommendationsParams,
	signal?: AbortSignal
) => {
	return customInstance<GetSegmentationRecommendationsResponse>({
		url: `/ai/segment-recommendations`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetAiChatSegmentRecommendationsQueryKey = (
	params?: GetAiChatSegmentRecommendationsParams
) => {
	return [`/ai/segment-recommendations`, ...(params ? [params] : [])] as const
}

export const getGetAiChatSegmentRecommendationsQueryOptions = <
	TData = Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetAiChatSegmentRecommendationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
				TError,
				TData
			>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetAiChatSegmentRecommendationsQueryKey(params)

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>> = ({
		signal
	}) => getAiChatSegmentRecommendations(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAiChatSegmentRecommendationsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>
>
export type GetAiChatSegmentRecommendationsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetAiChatSegmentRecommendations<
	TData = Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: undefined | GetAiChatSegmentRecommendationsParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
					TError,
					Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChatSegmentRecommendations<
	TData = Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetAiChatSegmentRecommendationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
					TError,
					Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAiChatSegmentRecommendations<
	TData = Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetAiChatSegmentRecommendationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
				TError,
				TData
			>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAiChatSegmentRecommendations<
	TData = Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params?: GetAiChatSegmentRecommendationsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getAiChatSegmentRecommendations>>,
				TError,
				TData
			>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetAiChatSegmentRecommendationsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}

/**
 * returns all ai chat response suggestions.
 */
export const getConversationResponseSuggestions = (
	params: GetConversationResponseSuggestionsParams,
	signal?: AbortSignal
) => {
	return customInstance<GetResponseSuggestionsResponse>({
		url: `/ai/response-suggestions`,
		method: 'GET',
		params,
		signal
	})
}

export const getGetConversationResponseSuggestionsQueryKey = (
	params: GetConversationResponseSuggestionsParams
) => {
	return [`/ai/response-suggestions`, ...(params ? [params] : [])] as const
}

export const getGetConversationResponseSuggestionsQueryOptions = <
	TData = Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationResponseSuggestionsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
				TError,
				TData
			>
		>
	}
) => {
	const { query: queryOptions } = options ?? {}

	const queryKey = queryOptions?.queryKey ?? getGetConversationResponseSuggestionsQueryKey(params)

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getConversationResponseSuggestions>>
	> = ({ signal }) => getConversationResponseSuggestions(params, signal)

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetConversationResponseSuggestionsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getConversationResponseSuggestions>>
>
export type GetConversationResponseSuggestionsQueryError =
	| BadRequestErrorResponseSchema
	| UnauthorizedErrorResponseSchema
	| NotFoundErrorResponseSchema
	| RateLimitErrorResponseSchema

export function useGetConversationResponseSuggestions<
	TData = Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationResponseSuggestionsParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
					TError,
					Awaited<ReturnType<typeof getConversationResponseSuggestions>>
				>,
				'initialData'
			>
	}
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationResponseSuggestions<
	TData = Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationResponseSuggestionsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
					TError,
					Awaited<ReturnType<typeof getConversationResponseSuggestions>>
				>,
				'initialData'
			>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetConversationResponseSuggestions<
	TData = Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationResponseSuggestionsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
				TError,
				TData
			>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetConversationResponseSuggestions<
	TData = Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
	TError =
		| BadRequestErrorResponseSchema
		| UnauthorizedErrorResponseSchema
		| NotFoundErrorResponseSchema
		| RateLimitErrorResponseSchema
>(
	params: GetConversationResponseSuggestionsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof getConversationResponseSuggestions>>,
				TError,
				TData
			>
		>
	}
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
	const queryOptions = getGetConversationResponseSuggestionsQueryOptions(params, options)

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData>
	}

	query.queryKey = queryOptions.queryKey

	return query
}
